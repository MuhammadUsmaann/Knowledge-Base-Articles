{"ast":null,"code":"/**\n * Tagify (v 4.17.6) - tags input component\n * By undefined\n * https://github.com/yairEO/tagify\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n * \r\n * THE SOFTWARE IS NOT PERMISSIBLE TO BE SOLD.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Tagify = factory());\n})(this, function () {\n  'use strict';\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n\n    return target;\n  }\n\n  function _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n\n    return (hint === \"string\" ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n\n    return typeof key === \"symbol\" ? key : String(key);\n  } // console.json = console.json || function(argument){\n  //     for(var arg=0; arg < arguments.length; ++arg)\n  //         console.log(  JSON.stringify(arguments[arg], null, 4)  )\n  // }\n  // const isEdge = /Edge/.test(navigator.userAgent)\n\n\n  const sameStr = (s1, s2, caseSensitive, trim) => {\n    // cast to String\n    s1 = \"\" + s1;\n    s2 = \"\" + s2;\n\n    if (trim) {\n      s1 = s1.trim();\n      s2 = s2.trim();\n    }\n\n    return caseSensitive ? s1 == s2 : s1.toLowerCase() == s2.toLowerCase();\n  }; // const getUID = () => (new Date().getTime() + Math.floor((Math.random()*10000)+1)).toString(16)\n\n\n  const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map(v => omit(v, unwantedProps));\n\n  function omit(obj, props) {\n    var newObj = {},\n        p;\n\n    for (p in obj) if (props.indexOf(p) < 0) newObj[p] = obj[p];\n\n    return newObj;\n  }\n\n  function decode(s) {\n    var el = document.createElement('div');\n    return s.replace(/\\&#?[0-9a-z]+;/gi, function (enc) {\n      el.innerHTML = enc;\n      return el.innerText;\n    });\n  }\n  /**\r\n   * utility method\r\n   * https://stackoverflow.com/a/35385518/104380\r\n   * @param  {String} s [HTML string]\r\n   * @return {Object}   [DOM node]\r\n   */\n\n\n  function parseHTML(s) {\n    var parser = new DOMParser(),\n        node = parser.parseFromString(s.trim(), \"text/html\");\n    return node.body.firstElementChild;\n  }\n  /**\r\n   * Removed new lines and irrelevant spaces which might affect layout, and are better gone\r\n   * @param {string} s [HTML string]\r\n   */\n\n\n  function minify(s) {\n    return s ? s.replace(/\\>[\\r\\n ]+\\</g, \"><\").replace(/(<.*?>)|\\s+/g, (m, $1) => $1 ? $1 : ' ') // https://stackoverflow.com/a/44841484/104380\n    : \"\";\n  }\n\n  function removeTextChildNodes(elm) {\n    var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false),\n        textnode; // print all text nodes\n\n    while (textnode = iter.nextNode()) {\n      if (!textnode.textContent.trim()) textnode.parentNode.removeChild(textnode);\n    }\n  }\n\n  function getfirstTextNode(elm, action) {\n    action = action || 'previous';\n\n    while (elm = elm[action + 'Sibling']) if (elm.nodeType == 3) return elm;\n  }\n  /**\r\n   * utility method\r\n   * https://stackoverflow.com/a/6234804/104380\r\n   */\n\n\n  function escapeHTML(s) {\n    return typeof s == 'string' ? s.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/`|'/g, \"&#039;\") : s;\n  }\n  /**\r\n   * Checks if an argument is a javascript Object\r\n   */\n\n\n  function isObject(obj) {\n    var type = Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);\n    return obj === Object(obj) && type != 'Array' && type != 'Function' && type != 'RegExp' && type != 'HTMLUnknownElement';\n  }\n  /**\r\n   * merge objects into a single new one\r\n   * TEST: extend({}, {a:{foo:1}, b:[]}, {a:{bar:2}, b:[1], c:()=>{}})\r\n   */\n\n\n  function extend(o, o1, o2) {\n    if (!(o instanceof Object)) o = {};\n    copy(o, o1);\n    if (o2) copy(o, o2);\n\n    function copy(a, b) {\n      // copy o2 to o\n      for (var key in b) if (b.hasOwnProperty(key)) {\n        if (isObject(b[key])) {\n          if (!isObject(a[key])) a[key] = Object.assign({}, b[key]);else copy(a[key], b[key]);\n          continue;\n        }\n\n        if (Array.isArray(b[key])) {\n          a[key] = Object.assign([], b[key]);\n          continue;\n        }\n\n        a[key] = b[key];\n      }\n    }\n\n    return o;\n  }\n  /**\r\n   * concatenates N arrays without dups.\r\n   * If an array's item is an Object, compare by `value`\r\n   */\n\n\n  function concatWithoutDups() {\n    const newArr = [],\n          existingObj = {};\n\n    for (let arr of arguments) {\n      for (let item of arr) {\n        // if current item is an object which has yet to be added to the new array\n        if (isObject(item)) {\n          if (!existingObj[item.value]) {\n            newArr.push(item);\n            existingObj[item.value] = 1;\n          }\n        } // if current item is not an object and is not in the new array\n        else if (!newArr.includes(item)) newArr.push(item);\n      }\n    }\n\n    return newArr;\n  }\n  /**\r\n   *  Extracted from: https://stackoverflow.com/a/37511463/104380\r\n   * @param {String} s\r\n   */\n\n\n  function unaccent(s) {\n    // if not supported, do not continue.\n    // developers should use a polyfill:\n    // https://github.com/walling/unorm\n    if (!String.prototype.normalize) return s;\n    if (typeof s === 'string') return s.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n  }\n  /**\r\n   * Meassures an element's height, which might yet have been added DOM\r\n   * https://stackoverflow.com/q/5944038/104380\r\n   * @param {DOM} node\r\n   */\n\n\n  function getNodeHeight(node) {\n    var height,\n        clone = node.cloneNode(true);\n    clone.style.cssText = \"position:fixed; top:-9999px; opacity:0\";\n    document.body.appendChild(clone);\n    height = clone.clientHeight;\n    clone.parentNode.removeChild(clone);\n    return height;\n  }\n\n  var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);\n\n  function getUID() {\n    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n  }\n\n  function isNodeTag(node) {\n    return node && node.classList && node.classList.contains(this.settings.classNames.tag);\n  }\n  /**\r\n  * Get the caret position relative to the viewport\r\n  * https://stackoverflow.com/q/58985076/104380\r\n  *\r\n  * @returns {object} left, top distance in pixels\r\n  */\n\n\n  function getCaretGlobalPosition() {\n    const sel = document.getSelection();\n\n    if (sel.rangeCount) {\n      const r = sel.getRangeAt(0);\n      const node = r.startContainer;\n      const offset = r.startOffset;\n      let rect, r2;\n\n      if (offset > 0) {\n        r2 = document.createRange();\n        r2.setStart(node, offset - 1);\n        r2.setEnd(node, offset);\n        rect = r2.getBoundingClientRect();\n        return {\n          left: rect.right,\n          top: rect.top,\n          bottom: rect.bottom\n        };\n      }\n\n      if (node.getBoundingClientRect) return node.getBoundingClientRect();\n    }\n\n    return {\n      left: -9999,\n      top: -9999\n    };\n  }\n  /**\r\n   * Injects content (either string or node) at the current the current (or specificed) caret position\r\n   * @param {content} string/node\r\n   * @param {range} Object (optional, a range other than the current window selection)\r\n   */\n\n\n  function injectAtCaret(content, range) {\n    var selection = window.getSelection();\n    range = range || selection.getRangeAt(0);\n    if (typeof content == 'string') content = document.createTextNode(content);\n\n    if (range) {\n      range.deleteContents();\n      range.insertNode(content);\n    }\n\n    return content;\n  }\n  /** Setter/Getter\r\n   * Each tag DOM node contains a custom property called \"__tagifyTagData\" which hosts its data\r\n   * @param {Node}   tagElm\r\n   * @param {Object} data\r\n   */\n\n\n  function getSetTagData(tagElm, data, override) {\n    if (!tagElm) {\n      console.warn(\"tag element doesn't exist\", tagElm, data);\n      return data;\n    }\n\n    if (data) tagElm.__tagifyTagData = override ? data : extend({}, tagElm.__tagifyTagData || {}, data);\n    return tagElm.__tagifyTagData;\n  }\n\n  var DEFAULTS = {\n    delimiters: \",\",\n    // [RegEx] split tags by any of these delimiters (\"null\" to cancel) Example: \",| |.\"\n    pattern: null,\n    // RegEx pattern to validate input by. Ex: /[1-9]/\n    tagTextProp: 'value',\n    // tag data Object property which will be displayed as the tag's text\n    maxTags: Infinity,\n    // Maximum number of tags\n    callbacks: {},\n    // Exposed callbacks object to be triggered on certain events\n    addTagOnBlur: true,\n    // automatically adds the text which was inputed as a tag when blur event happens\n    onChangeAfterBlur: true,\n    // By default, the native way of inputs' onChange events is kept, and it only fires when the field is blured.\n    duplicates: false,\n    // \"true\" - allow duplicate tags\n    whitelist: [],\n    // Array of tags to suggest as the user types (can be used along with \"enforceWhitelist\" setting)\n    blacklist: [],\n    // A list of non-allowed tags\n    enforceWhitelist: false,\n    // Only allow tags from the whitelist\n    userInput: true,\n    // disable manually typing/pasting/editing tags (tags may only be added from the whitelist)\n    keepInvalidTags: false,\n    // if true, do not remove tags which did not pass validation\n    createInvalidTags: true,\n    // if false, do not create invalid tags from invalid user input\n    mixTagsAllowedAfter: /,|\\.|\\:|\\s/,\n    // RegEx - Define conditions in which mix-tags content allows a tag to be added after\n    mixTagsInterpolator: ['[[', ']]'],\n    // Interpolation for mix mode. Everything between these will become a tag, if is a valid Object\n    backspace: true,\n    // false / true / \"edit\"\n    skipInvalid: false,\n    // If `true`, do not add invalid, temporary, tags before automatically removing them\n    pasteAsTags: true,\n    // automatically converts pasted text into tags. if \"false\", allows for further text editing\n    editTags: {\n      clicks: 2,\n      // clicks to enter \"edit-mode\": 1 for single click. any other value is considered as double-click\n      keepInvalid: true // keeps invalid edits as-is until `esc` is pressed while in focus\n\n    },\n    // 1 or 2 clicks to edit a tag. false/null for not allowing editing\n    transformTag: () => {},\n    // Takes a tag input string as argument and returns a transformed value\n    trim: true,\n    // whether or not the value provided should be trimmed, before being added as a tag\n    a11y: {\n      focusableTags: false\n    },\n    mixMode: {\n      insertAfterTag: '\\u00A0' // String/Node to inject after a tag has been added (see #588)\n\n    },\n    autoComplete: {\n      enabled: true,\n      // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text\n      rightKey: false // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to \"true\"\n\n    },\n    classNames: {\n      namespace: 'tagify',\n      mixMode: 'tagify--mix',\n      selectMode: 'tagify--select',\n      input: 'tagify__input',\n      focus: 'tagify--focus',\n      tagNoAnimation: 'tagify--noAnim',\n      tagInvalid: 'tagify--invalid',\n      tagNotAllowed: 'tagify--notAllowed',\n      scopeLoading: 'tagify--loading',\n      hasMaxTags: 'tagify--hasMaxTags',\n      hasNoTags: 'tagify--noTags',\n      empty: 'tagify--empty',\n      inputInvalid: 'tagify__input--invalid',\n      dropdown: 'tagify__dropdown',\n      dropdownWrapper: 'tagify__dropdown__wrapper',\n      dropdownHeader: 'tagify__dropdown__header',\n      dropdownFooter: 'tagify__dropdown__footer',\n      dropdownItem: 'tagify__dropdown__item',\n      dropdownItemActive: 'tagify__dropdown__item--active',\n      dropdownItemHidden: 'tagify__dropdown__item--hidden',\n      dropdownInital: 'tagify__dropdown--initial',\n      tag: 'tagify__tag',\n      tagText: 'tagify__tag-text',\n      tagX: 'tagify__tag__removeBtn',\n      tagLoading: 'tagify__tag--loading',\n      tagEditing: 'tagify__tag--editable',\n      tagFlash: 'tagify__tag--flash',\n      tagHide: 'tagify__tag--hide'\n    },\n    dropdown: {\n      classname: '',\n      enabled: 2,\n      // minimum input characters to be typed for the suggestions dropdown to show\n      maxItems: 10,\n      searchKeys: [\"value\", \"searchBy\"],\n      fuzzySearch: true,\n      caseSensitive: false,\n      accentedSearch: true,\n      includeSelectedTags: false,\n      // Should the suggestions list Include already-selected tags (after filtering)\n      highlightFirst: false,\n      // highlights first-matched item in the list\n      closeOnSelect: true,\n      // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)\n      clearOnSelect: true,\n      // after selecting a suggetion, should the typed text input remain or be cleared\n      position: 'all',\n      // 'manual' / 'text' / 'all'\n      appendTarget: null // defaults to document.body once DOM has been loaded\n\n    },\n    hooks: {\n      beforeRemoveTag: () => Promise.resolve(),\n      beforePaste: () => Promise.resolve(),\n      suggestionClick: () => Promise.resolve()\n    }\n  };\n\n  function initDropdown() {\n    this.dropdown = {}; // auto-bind \"this\" to all the dropdown methods\n\n    for (let p in this._dropdown) this.dropdown[p] = typeof this._dropdown[p] === 'function' ? this._dropdown[p].bind(this) : this._dropdown[p];\n\n    this.dropdown.refs();\n  }\n\n  var _dropdown = {\n    refs() {\n      this.DOM.dropdown = this.parseTemplate('dropdown', [this.settings]);\n      this.DOM.dropdown.content = this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-wrapper']\");\n    },\n\n    getHeaderRef() {\n      return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-header']\");\n    },\n\n    getFooterRef() {\n      return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-footer']\");\n    },\n\n    getAllSuggestionsRefs() {\n      return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)];\n    },\n\n    /**\r\n     * shows the suggestions select box\r\n     * @param {String} value [optional, filter the whitelist by this value]\r\n     */\n    show(value) {\n      var _s = this.settings,\n          firstListItem,\n          firstListItemValue,\n          allowNewTags = _s.mode == 'mix' && !_s.enforceWhitelist,\n          noWhitelist = !_s.whitelist || !_s.whitelist.length,\n          noMatchListItem,\n          isManual = _s.dropdown.position == 'manual'; // if text still exists in the input, and `show` method has no argument, then the input's text should be used\n\n      value = value === undefined ? this.state.inputText : value; // ⚠️ Do not render suggestions list  if:\n      // 1. there's no whitelist (can happen while async loading) AND new tags arn't allowed\n      // 2. dropdown is disabled\n      // 3. loader is showing (controlled outside of this code)\n\n      if (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch || _s.dropdown.enable === false || this.state.isLoading || this.settings.readonly) return;\n      clearTimeout(this.dropdownHide__bindEventsTimeout); // if no value was supplied, show all the \"whitelist\" items in the dropdown\n      // @type [Array] listItems\n      // TODO: add a Setting to control items' sort order for \"listItems\"\n\n      this.suggestedListItems = this.dropdown.filterListItems(value); // trigger at this exact point to let the developer the chance to manually set \"this.suggestedListItems\"\n\n      if (value && !this.suggestedListItems.length) {\n        this.trigger('dropdown:noMatch', value);\n        if (_s.templates.dropdownItemNoMatch) noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {\n          value\n        });\n      } // if \"dropdownItemNoMatch\" was no defined, procceed regular flow.\n      //\n\n\n      if (!noMatchListItem) {\n        // in mix-mode, if the value isn't included in the whilelist & \"enforceWhitelist\" setting is \"false\",\n        // then add a custom suggestion item to the dropdown\n        if (this.suggestedListItems.length) {\n          if (value && allowNewTags && !this.state.editing.scope && !sameStr(this.suggestedListItems[0].value, value)) this.suggestedListItems.unshift({\n            value\n          });\n        } else {\n          if (value && allowNewTags && !this.state.editing.scope) {\n            this.suggestedListItems = [{\n              value\n            }];\n          } // hide suggestions list if no suggestion matched\n          else {\n              this.input.autocomplete.suggest.call(this);\n              this.dropdown.hide();\n              return;\n            }\n        }\n\n        firstListItem = this.suggestedListItems[0];\n        firstListItemValue = \"\" + (isObject(firstListItem) ? firstListItem.value : firstListItem);\n\n        if (_s.autoComplete && firstListItemValue) {\n          // only fill the sugegstion if the value of the first list item STARTS with the input value (regardless of \"fuzzysearch\" setting)\n          if (firstListItemValue.indexOf(value) == 0) this.input.autocomplete.suggest.call(this, firstListItem);\n        }\n      }\n\n      this.dropdown.fill(noMatchListItem);\n\n      if (_s.dropdown.highlightFirst) {\n        this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(_s.classNames.dropdownItemSelector));\n      } // bind events, exactly at this stage of the code. \"dropdown.show\" method is allowed to be\n      // called multiple times, regardless if the dropdown is currently visible, but the events-binding\n      // should only be called if the dropdown wasn't previously visible.\n\n\n      if (!this.state.dropdown.visible) // timeout is needed for when pressing arrow down to show the dropdown,\n        // so the key event won't get registered in the dropdown events listeners\n        setTimeout(this.dropdown.events.binding.bind(this)); // set the dropdown visible state to be the same as the searched value.\n      // MUST be set *before* position() is called\n\n      this.state.dropdown.visible = value || true;\n      this.state.dropdown.query = value;\n      this.setStateSelection(); // try to positioning the dropdown (it might not yet be on the page, doesn't matter, next code handles this)\n\n      if (!isManual) {\n        // a slight delay is needed if the dropdown \"position\" setting is \"text\", and nothing was typed in the input,\n        // so sadly the \"getCaretGlobalPosition\" method doesn't recognize the caret position without this delay\n        setTimeout(() => {\n          this.dropdown.position();\n          this.dropdown.render();\n        });\n      } // a delay is needed because of the previous delay reason.\n      // this event must be fired after the dropdown was rendered & positioned\n\n\n      setTimeout(() => {\n        this.trigger(\"dropdown:show\", this.DOM.dropdown);\n      });\n    },\n\n    /**\r\n     * Hides the dropdown (if it's not managed manually by the developer)\r\n     * @param {Boolean} overrideManual\r\n     */\n    hide(overrideManual) {\n      var _this$DOM = this.DOM,\n          scope = _this$DOM.scope,\n          dropdown = _this$DOM.dropdown,\n          isManual = this.settings.dropdown.position == 'manual' && !overrideManual; // if there's no dropdown, this means the dropdown events aren't binded\n\n      if (!dropdown || !document.body.contains(dropdown) || isManual) return;\n      window.removeEventListener('resize', this.dropdown.position);\n      this.dropdown.events.binding.call(this, false); // unbind all events\n      // if the dropdown is open, and the input (scope) is clicked,\n      // the dropdown should be now \"close\", and the next click (on the scope)\n      // should re-open it, and without a timeout, clicking to close will re-open immediately\n      //  clearTimeout(this.dropdownHide__bindEventsTimeout)\n      //  this.dropdownHide__bindEventsTimeout = setTimeout(this.events.binding.bind(this), 250)  // re-bind main events\n\n      scope.setAttribute(\"aria-expanded\", false);\n      dropdown.parentNode.removeChild(dropdown); // scenario: clicking the scope to show the dropdown, clicking again to hide -> calls dropdown.hide() and then re-focuses the input\n      // which casues another onFocus event, which checked \"this.state.dropdown.visible\" and see it as \"false\" and re-open the dropdown\n\n      setTimeout(() => {\n        this.state.dropdown.visible = false;\n      }, 100);\n      this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null; // if the user closed the dropdown (in mix-mode) while a potential tag was detected, flag the current tag\n      // so the dropdown won't be shown on following user input for that \"tag\"\n\n      if (this.state.tag && this.state.tag.value.length) {\n        this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag;\n      }\n\n      this.trigger(\"dropdown:hide\", dropdown);\n      return this;\n    },\n\n    /**\r\n     * Toggles dropdown show/hide\r\n     * @param {Boolean} show forces the dropdown to show\r\n     */\n    toggle(show) {\n      this.dropdown[this.state.dropdown.visible && !show ? 'hide' : 'show']();\n    },\n\n    render() {\n      // let the element render in the DOM first, to accurately measure it.\n      // this.DOM.dropdown.style.cssText = \"left:-9999px; top:-9999px;\";\n      var ddHeight = getNodeHeight(this.DOM.dropdown),\n          _s = this.settings,\n          enabled = typeof _s.dropdown.enabled == 'number' && _s.dropdown.enabled >= 0;\n      if (!enabled) return this;\n      this.DOM.scope.setAttribute(\"aria-expanded\", true); // if the dropdown has yet to be appended to the DOM,\n      // append the dropdown to the body element & handle events\n\n      if (!document.body.contains(this.DOM.dropdown)) {\n        this.DOM.dropdown.classList.add(_s.classNames.dropdownInital);\n        this.dropdown.position(ddHeight);\n\n        _s.dropdown.appendTarget.appendChild(this.DOM.dropdown);\n\n        setTimeout(() => this.DOM.dropdown.classList.remove(_s.classNames.dropdownInital));\n      }\n\n      return this;\n    },\n\n    /**\r\n     * re-renders the dropdown content element (see \"dropdownContent\" in templates file)\r\n     * @param {String/Array} HTMLContent - optional\r\n     */\n    fill(HTMLContent) {\n      HTMLContent = typeof HTMLContent == 'string' ? HTMLContent : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems);\n      var dropdownContent = this.settings.templates.dropdownContent.call(this, HTMLContent);\n      this.DOM.dropdown.content.innerHTML = minify(dropdownContent);\n    },\n\n    /**\r\n     * Re-renders only the header & footer.\r\n     * Used when selecting a suggestion and it is wanted that the suggestions dropdown stays open.\r\n     * Since the list of sugegstions is not being re-rendered completely every time a suggestion is selected (the item is transitioned-out)\r\n     * then the header & footer should be kept in sync with the suggestions data change\r\n     */\n    fillHeaderFooter() {\n      var suggestions = this.dropdown.filterListItems(this.state.dropdown.query),\n          newHeaderElem = this.parseTemplate('dropdownHeader', [suggestions]),\n          newFooterElem = this.parseTemplate('dropdownFooter', [suggestions]),\n          headerRef = this.dropdown.getHeaderRef(),\n          footerRef = this.dropdown.getFooterRef();\n      newHeaderElem && (headerRef === null || headerRef === void 0 ? void 0 : headerRef.parentNode.replaceChild(newHeaderElem, headerRef));\n      newFooterElem && (footerRef === null || footerRef === void 0 ? void 0 : footerRef.parentNode.replaceChild(newFooterElem, footerRef));\n    },\n\n    /**\r\n     * fill data into the suggestions list\r\n     * (mainly used to update the list when removing tags while the suggestions dropdown is visible, so they will be re-added to the list. not efficient)\r\n     */\n    refilter(value) {\n      value = value || this.state.dropdown.query || '';\n      this.suggestedListItems = this.dropdown.filterListItems(value);\n      this.dropdown.fill();\n      if (!this.suggestedListItems.length) this.dropdown.hide();\n      this.trigger(\"dropdown:updated\", this.DOM.dropdown);\n    },\n\n    position(ddHeight) {\n      var _sd = this.settings.dropdown;\n      if (_sd.position == 'manual') return;\n      var rect,\n          top,\n          bottom,\n          left,\n          width,\n          parentsPositions,\n          ddElm = this.DOM.dropdown,\n          placeAbove = _sd.placeAbove,\n          isDefaultAppendTarget = _sd.appendTarget === document.body,\n          appendTargetScrollTop = isDefaultAppendTarget ? window.pageYOffset : _sd.appendTarget.scrollTop,\n          root = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement,\n          viewportHeight = root.clientHeight,\n          viewportWidth = Math.max(root.clientWidth || 0, window.innerWidth || 0),\n          positionTo = viewportWidth > 480 ? _sd.position : 'all',\n          ddTarget = this.DOM[positionTo == 'input' ? 'input' : 'scope'];\n      ddHeight = ddHeight || ddElm.clientHeight;\n\n      function getParentsPositions(p) {\n        var left = 0,\n            top = 0; // when in element-fullscreen mode, do not go above the fullscreened-element\n\n        while (p && p != root) {\n          left += p.offsetLeft || 0;\n          top += p.offsetTop || 0;\n          p = p.parentNode;\n        }\n\n        return {\n          left,\n          top\n        };\n      }\n\n      function getAccumulatedAncestorsScrollTop() {\n        var scrollTop = 0,\n            p = _sd.appendTarget.parentNode;\n\n        while (p) {\n          scrollTop += p.scrollTop || 0;\n          p = p.parentNode;\n        }\n\n        return scrollTop;\n      }\n\n      if (!this.state.dropdown.visible) return;\n\n      if (positionTo == 'text') {\n        rect = getCaretGlobalPosition();\n        bottom = rect.bottom;\n        top = rect.top;\n        left = rect.left;\n        width = 'auto';\n      } else {\n        parentsPositions = getParentsPositions(_sd.appendTarget);\n        rect = ddTarget.getBoundingClientRect();\n        top = rect.top - parentsPositions.top;\n        bottom = rect.bottom - 1 - parentsPositions.top;\n        left = rect.left - parentsPositions.left;\n        width = rect.width + 'px';\n      } // if the \"append target\" isn't the default, correct the `top` variable by ignoring any scrollTop of the target's Ancestors\n\n\n      if (!isDefaultAppendTarget) {\n        let accumulatedAncestorsScrollTop = getAccumulatedAncestorsScrollTop();\n        top += accumulatedAncestorsScrollTop;\n        bottom += accumulatedAncestorsScrollTop;\n      }\n\n      top = Math.floor(top);\n      bottom = Math.ceil(bottom);\n      placeAbove = placeAbove === undefined ? viewportHeight - rect.bottom < ddHeight : placeAbove; // flip vertically if there is no space for the dropdown below the input\n\n      ddElm.style.cssText = \"left:\" + (left + window.pageXOffset) + \"px; width:\" + width + \";\" + (placeAbove ? \"top: \" + (top + appendTargetScrollTop) + \"px\" : \"top: \" + (bottom + appendTargetScrollTop) + \"px\");\n      ddElm.setAttribute('placement', placeAbove ? \"top\" : \"bottom\");\n      ddElm.setAttribute('position', positionTo);\n    },\n\n    events: {\n      /**\r\n       * Events should only be binded when the dropdown is rendered and removed when isn't\r\n       * because there might be multiple Tagify instances on a certain page\r\n       * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]\r\n       */\n      binding() {\n        let bindUnbind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true; // references to the \".bind()\" methods must be saved so they could be unbinded later\n\n        var _CB = this.dropdown.events.callbacks,\n            // callback-refs\n        _CBR = this.listeners.dropdown = this.listeners.dropdown || {\n          position: this.dropdown.position.bind(this, null),\n          onKeyDown: _CB.onKeyDown.bind(this),\n          onMouseOver: _CB.onMouseOver.bind(this),\n          onMouseLeave: _CB.onMouseLeave.bind(this),\n          onClick: _CB.onClick.bind(this),\n          onScroll: _CB.onScroll.bind(this)\n        },\n            action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n        if (this.settings.dropdown.position != 'manual') {\n          document[action]('scroll', _CBR.position, true);\n          window[action]('resize', _CBR.position);\n          window[action]('keydown', _CBR.onKeyDown);\n        }\n\n        this.DOM.dropdown[action]('mouseover', _CBR.onMouseOver);\n        this.DOM.dropdown[action]('mouseleave', _CBR.onMouseLeave);\n        this.DOM.dropdown[action]('mousedown', _CBR.onClick);\n        this.DOM.dropdown.content[action]('scroll', _CBR.onScroll);\n      },\n\n      callbacks: {\n        onKeyDown(e) {\n          // ignore keys during IME composition\n          if (!this.state.hasFocus || this.state.composing) return; // get the \"active\" element, and if there was none (yet) active, use first child\n\n          var selectedElm = this.DOM.dropdown.querySelector(this.settings.classNames.dropdownItemActiveSelector),\n              selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm);\n\n          switch (e.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'Down': // >IE11\n\n            case 'Up':\n              {\n                // >IE11\n                e.preventDefault();\n                var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n                    actionUp = e.key == 'ArrowUp' || e.key == 'Up';\n\n                if (selectedElm) {\n                  selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp);\n                } // if no element was found OR current item is not a \"real\" item, loop\n\n\n                if (!selectedElm || !selectedElm.matches(this.settings.classNames.dropdownItemSelector)) {\n                  selectedElm = dropdownItems[actionUp ? dropdownItems.length - 1 : 0];\n                }\n\n                this.dropdown.highlightOption(selectedElm, true); // selectedElm.scrollIntoView({inline: 'nearest', behavior: 'smooth'})\n\n                break;\n              }\n\n            case 'Escape':\n            case 'Esc':\n              // IE11\n              this.dropdown.hide();\n              break;\n\n            case 'ArrowRight':\n              if (this.state.actions.ArrowLeft) return;\n\n            case 'Tab':\n              {\n                // in mix-mode, treat arrowRight like Enter key, so a tag will be created\n                if (this.settings.mode != 'mix' && selectedElm && !this.settings.autoComplete.rightKey && !this.state.editing) {\n                  e.preventDefault(); // prevents blur so the autocomplete suggestion will not become a tag\n\n                  var value = this.dropdown.getMappedValue(selectedElmData);\n                  this.input.autocomplete.set.call(this, value);\n                  return false;\n                }\n\n                return true;\n              }\n\n            case 'Enter':\n              {\n                e.preventDefault();\n                this.settings.hooks.suggestionClick(e, {\n                  tagify: this,\n                  tagData: selectedElmData,\n                  suggestionElm: selectedElm\n                }).then(() => {\n                  if (selectedElm) {\n                    this.dropdown.selectOption(selectedElm); // highlight next option\n\n                    selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp);\n                    this.dropdown.highlightOption(selectedElm);\n                    return;\n                  } else this.dropdown.hide();\n\n                  if (this.settings.mode != 'mix') this.addTags(this.state.inputText.trim(), true);\n                }).catch(err => err);\n                break;\n              }\n\n            case 'Backspace':\n              {\n                if (this.settings.mode == 'mix' || this.state.editing.scope) return;\n                const value = this.input.raw.call(this);\n\n                if (value == \"\" || value.charCodeAt(0) == 8203) {\n                  if (this.settings.backspace === true) this.removeTags();else if (this.settings.backspace == 'edit') setTimeout(this.editTag.bind(this), 0);\n                }\n              }\n          }\n        },\n\n        onMouseOver(e) {\n          var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector); // event delegation check\n\n          ddItem && this.dropdown.highlightOption(ddItem);\n        },\n\n        onMouseLeave(e) {\n          // de-highlight any previously highlighted option\n          this.dropdown.highlightOption();\n        },\n\n        onClick(e) {\n          if (e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content) return; // allow only mouse left-clicks\n\n          var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector),\n              selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm); // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't run\n\n          this.state.actions.selectOption = true;\n          setTimeout(() => this.state.actions.selectOption = false, 50);\n          this.settings.hooks.suggestionClick(e, {\n            tagify: this,\n            tagData: selectedElmData,\n            suggestionElm: selectedElm\n          }).then(() => {\n            if (selectedElm) this.dropdown.selectOption(selectedElm, e);else this.dropdown.hide();\n          }).catch(err => console.warn(err));\n        },\n\n        onScroll(e) {\n          var elm = e.target,\n              pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;\n          this.trigger(\"dropdown:scroll\", {\n            percentage: Math.round(pos)\n          });\n        }\n\n      }\n    },\n\n    /**\r\n     * Given a suggestion-item, return the data associated with it\r\n     * @param {HTMLElement} tagElm\r\n     * @returns Object\r\n     */\n    getSuggestionDataByNode(tagElm) {\n      var value = tagElm && tagElm.getAttribute('value');\n      return this.suggestedListItems.find(item => item.value == value) || null;\n    },\n\n    getNextOrPrevOption(selected) {\n      let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n          selectedIdx = dropdownItems.findIndex(item => item === selected);\n      return next ? dropdownItems[selectedIdx + 1] : dropdownItems[selectedIdx - 1];\n    },\n\n    /**\r\n     * mark the currently active suggestion option\r\n     * @param {Object}  elm            option DOM node\r\n     * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), aut-scroll to always show the highlighted element\r\n     */\n    highlightOption(elm, adjustScroll) {\n      var className = this.settings.classNames.dropdownItemActive,\n          itemData; // focus casues a bug in Firefox with the placeholder been shown on the input element\n      // if( this.settings.dropdown.position != 'manual' )\n      //     elm.focus();\n\n      if (this.state.ddItemElm) {\n        this.state.ddItemElm.classList.remove(className);\n        this.state.ddItemElm.removeAttribute(\"aria-selected\");\n      }\n\n      if (!elm) {\n        this.state.ddItemData = null;\n        this.state.ddItemElm = null;\n        this.input.autocomplete.suggest.call(this);\n        return;\n      }\n\n      itemData = this.dropdown.getSuggestionDataByNode(elm);\n      this.state.ddItemData = itemData;\n      this.state.ddItemElm = elm; // this.DOM.dropdown.querySelectorAll(\".\" + this.settings.classNames.dropdownItemActive).forEach(activeElm => activeElm.classList.remove(className));\n\n      elm.classList.add(className);\n      elm.setAttribute(\"aria-selected\", true);\n      if (adjustScroll) elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight; // Try to autocomplete the typed value with the currently highlighted dropdown item\n\n      if (this.settings.autoComplete) {\n        this.input.autocomplete.suggest.call(this, itemData);\n        this.dropdown.position(); // suggestions might alter the height of the tagify wrapper because of unkown suggested term length that could drop to the next line\n      }\n    },\n\n    /**\r\n     * Create a tag from the currently active suggestion option\r\n     * @param {Object} elm  DOM node to select\r\n     * @param {Object} event The original Click event, if available (since keyboard ENTER key also triggers this method)\r\n     */\n    selectOption(elm, event) {\n      var _this$settings$dropdo = this.settings.dropdown,\n          clearOnSelect = _this$settings$dropdo.clearOnSelect,\n          closeOnSelect = _this$settings$dropdo.closeOnSelect;\n\n      if (!elm) {\n        this.addTags(this.state.inputText, true);\n        closeOnSelect && this.dropdown.hide();\n        return;\n      }\n\n      event = event || {}; // if in edit-mode, do not continue but instead replace the tag's text.\n      // the scenario is that \"addTags\" was called from a dropdown suggested option selected while editing\n\n      var value = elm.getAttribute('value'),\n          isNoMatch = value == 'noMatch',\n          tagData = this.suggestedListItems.find(item => (item.value || item) == value); // The below event must be triggered, regardless of anything else which might go wrong\n\n      this.trigger('dropdown:select', {\n        data: tagData,\n        elm,\n        event\n      });\n\n      if (!value || !tagData && !isNoMatch) {\n        closeOnSelect && setTimeout(this.dropdown.hide.bind(this));\n        return;\n      }\n\n      if (this.state.editing) {\n        // normalizing value, because \"tagData\" might be a string, and therefore will not be able to extend the object\n        this.onEditTagDone(null, extend({\n          __isValid: true\n        }, this.normalizeTags([tagData])[0]));\n      } // Tagify instances should re-focus to the input element once an option was selected, to allow continuous typing\n      else {\n          this[this.settings.mode == 'mix' ? \"addMixTags\" : \"addTags\"]([tagData || this.input.raw.call(this)], clearOnSelect);\n        } // todo: consider not doing this on mix-mode\n\n\n      if (!this.DOM.input.parentNode) return;\n      setTimeout(() => {\n        this.DOM.input.focus();\n        this.toggleFocusClass(true);\n        this.setRangeAtStartEnd(false, this.DOM.input);\n      });\n      closeOnSelect && setTimeout(this.dropdown.hide.bind(this)); // hide selected suggestion\n\n      elm.addEventListener('transitionend', () => {\n        this.dropdown.fillHeaderFooter();\n        setTimeout(() => elm.remove(), 100);\n      }, {\n        once: true\n      });\n      elm.classList.add(this.settings.classNames.dropdownItemHidden);\n    },\n\n    // adds all the suggested items, including the ones which are not currently rendered,\n    // unless specified otherwise (by the \"onlyRendered\" argument)\n    selectAll(onlyRendered) {\n      // having suggestedListItems with items messes with \"normalizeTags\" when wanting\n      // to add all tags\n      this.suggestedListItems.length = 0;\n      this.dropdown.hide();\n      this.dropdown.filterListItems('');\n      var tagsToAdd = this.dropdown.filterListItems('');\n      if (!onlyRendered) tagsToAdd = this.state.dropdown.suggestions; // some whitelist items might have already been added as tags so when addings all of them,\n      // skip adding already-added ones, so best to use \"filterListItems\" method over \"settings.whitelist\"\n\n      this.addTags(tagsToAdd, true);\n      return this;\n    },\n\n    /**\r\n     * returns an HTML string of the suggestions' list items\r\n     * @param {String} value string to filter the whitelist by\r\n     * @param {Object} options \"exact\" - for exact complete match\r\n     * @return {Array} list of filtered whitelist items according to the settings provided and current value\r\n     */\n    filterListItems(value, options) {\n      var _s = this.settings,\n          _sd = _s.dropdown,\n          options = options || {},\n          list = [],\n          exactMatchesList = [],\n          whitelist = _s.whitelist,\n          suggestionsCount = _sd.maxItems >= 0 ? _sd.maxItems : Infinity,\n          searchKeys = _sd.searchKeys,\n          whitelistItem,\n          valueIsInWhitelist,\n          searchBy,\n          isDuplicate,\n          niddle,\n          i = 0;\n      value = _s.mode == 'select' && this.value.length && this.value[0][_s.tagTextProp] == value ? '' // do not filter if the tag, which is already selecetd in \"select\" mode, is the same as the typed text\n      : value;\n\n      if (!value || !searchKeys.length) {\n        list = _sd.includeSelectedTags ? whitelist : whitelist.filter(item => !this.isTagDuplicate(isObject(item) ? item.value : item)); // don't include tags which have already been added.\n\n        this.state.dropdown.suggestions = list;\n        return list.slice(0, suggestionsCount); // respect \"maxItems\" dropdown setting\n      }\n\n      niddle = _sd.caseSensitive ? \"\" + value : (\"\" + value).toLowerCase(); // checks if ALL of the words in the search query exists in the current whitelist item, regardless of their order\n\n      function stringHasAll(s, query) {\n        return query.toLowerCase().split(' ').every(q => s.includes(q.toLowerCase()));\n      }\n\n      for (; i < whitelist.length; i++) {\n        let startsWithMatch, exactMatch;\n        whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : {\n          value: whitelist[i]\n        }; //normalize value as an Object\n\n        let itemWithoutSearchKeys = !Object.keys(whitelistItem).some(k => searchKeys.includes(k)),\n            _searchKeys = itemWithoutSearchKeys ? [\"value\"] : searchKeys;\n\n        if (_sd.fuzzySearch && !options.exact) {\n          searchBy = _searchKeys.reduce((values, k) => values + \" \" + (whitelistItem[k] || \"\"), \"\").toLowerCase().trim();\n\n          if (_sd.accentedSearch) {\n            searchBy = unaccent(searchBy);\n            niddle = unaccent(niddle);\n          }\n\n          startsWithMatch = searchBy.indexOf(niddle) == 0;\n          exactMatch = searchBy === niddle;\n          valueIsInWhitelist = stringHasAll(searchBy, niddle);\n        } else {\n          startsWithMatch = true;\n          valueIsInWhitelist = _searchKeys.some(k => {\n            var v = '' + (whitelistItem[k] || ''); // if key exists, cast to type String\n\n            if (_sd.accentedSearch) {\n              v = unaccent(v);\n              niddle = unaccent(niddle);\n            }\n\n            if (!_sd.caseSensitive) v = v.toLowerCase();\n            exactMatch = v === niddle;\n            return options.exact ? v === niddle : v.indexOf(niddle) == 0;\n          });\n        }\n\n        isDuplicate = !_sd.includeSelectedTags && this.isTagDuplicate(isObject(whitelistItem) ? whitelistItem.value : whitelistItem); // match for the value within each \"whitelist\" item\n\n        if (valueIsInWhitelist && !isDuplicate) if (exactMatch && startsWithMatch) exactMatchesList.push(whitelistItem);else if (_sd.sortby == 'startsWith' && startsWithMatch) list.unshift(whitelistItem);else list.push(whitelistItem);\n      }\n\n      this.state.dropdown.suggestions = exactMatchesList.concat(list); // custom sorting function\n\n      return typeof _sd.sortby == 'function' ? _sd.sortby(exactMatchesList.concat(list), niddle) : exactMatchesList.concat(list).slice(0, suggestionsCount);\n    },\n\n    /**\r\n     * Returns the final value of a tag data (object) with regards to the \"mapValueTo\" dropdown setting\r\n     * @param {Object} tagData\r\n     * @returns\r\n     */\n    getMappedValue(tagData) {\n      var mapValueTo = this.settings.dropdown.mapValueTo,\n          value = mapValueTo ? typeof mapValueTo == 'function' ? mapValueTo(tagData) : tagData[mapValueTo] || tagData.value : tagData.value;\n      return value;\n    },\n\n    /**\r\n     * Creates the dropdown items' HTML\r\n     * @param  {Array} sugegstionsList  [Array of Objects]\r\n     * @return {String}\r\n     */\n    createListHTML(sugegstionsList) {\n      return extend([], sugegstionsList).map((suggestion, idx) => {\n        if (typeof suggestion == 'string' || typeof suggestion == 'number') suggestion = {\n          value: suggestion\n        };\n        var mappedValue = this.dropdown.getMappedValue(suggestion);\n        mappedValue = typeof mappedValue == 'string' ? escapeHTML(mappedValue) : mappedValue;\n        return this.settings.templates.dropdownItem.apply(this, [_objectSpread2(_objectSpread2({}, suggestion), {}, {\n          mappedValue\n        }), this]);\n      }).join(\"\");\n    }\n\n  };\n  const VERSION = 1; // current version of persisted data. if code change breaks persisted data, verison number should be bumped.\n\n  const STORE_KEY = '@yaireo/tagify/';\n\n  const getPersistedData = id => key => {\n    // if \"persist\" is \"false\", do not save to localstorage\n    let customKey = '/' + key,\n        persistedData,\n        versionMatch = localStorage.getItem(STORE_KEY + id + '/v', VERSION) == VERSION;\n\n    if (versionMatch) {\n      try {\n        persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]);\n      } catch (err) {}\n    }\n\n    return persistedData;\n  };\n\n  const setPersistedData = id => {\n    if (!id) return () => {}; // for storage invalidation\n\n    localStorage.setItem(STORE_KEY + id + '/v', VERSION);\n    return (data, key) => {\n      let customKey = '/' + key,\n          persistedData = JSON.stringify(data);\n\n      if (data && key) {\n        localStorage.setItem(STORE_KEY + id + customKey, persistedData);\n        dispatchEvent(new Event('storage'));\n      }\n    };\n  };\n\n  const clearPersistedData = id => key => {\n    const base = STORE_KEY + '/' + id + '/'; // delete specific key in the storage\n\n    if (key) localStorage.removeItem(base + key); // delete all keys in the storage with a specific tagify id\n    else {\n        for (let k in localStorage) if (k.includes(base)) localStorage.removeItem(k);\n      }\n  };\n\n  var TEXTS = {\n    empty: \"empty\",\n    exceed: \"number of tags exceeded\",\n    pattern: \"pattern mismatch\",\n    duplicate: \"already exists\",\n    notAllowed: \"not allowed\"\n  };\n  var templates = {\n    /**\r\n     *\r\n     * @param {DOM Object} input     Original input DOm element\r\n     * @param {Object}     settings  Tagify instance settings Object\r\n     */\n    wrapper(input, _s) {\n      return `<tags class=\"${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + \"Mode\"]}` : \"\"} ${input.className}\"\n                    ${_s.readonly ? 'readonly' : ''}\n                    ${_s.disabled ? 'disabled' : ''}\n                    ${_s.required ? 'required' : ''}\n                    ${_s.mode === 'select' ? \"spellcheck='false'\" : ''}\n                    tabIndex=\"-1\">\n            <span ${!_s.readonly && _s.userInput ? 'contenteditable' : ''} tabIndex=\"0\" data-placeholder=\"${_s.placeholder || '&#8203;'}\" aria-placeholder=\"${_s.placeholder || ''}\"\n                class=\"${_s.classNames.input}\"\n                role=\"textbox\"\n                aria-autocomplete=\"both\"\n                aria-multiline=\"${_s.mode == 'mix' ? true : false}\"></span>\n                &#8203;\n        </tags>`;\n    },\n\n    tag(tagData, _ref) {\n      let _s = _ref.settings;\n      return `<tag title=\"${tagData.title || tagData.value}\"\n                    contenteditable='false'\n                    spellcheck='false'\n                    tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\"\n                    class=\"${_s.classNames.tag} ${tagData.class || \"\"}\"\n                    ${this.getAttributes(tagData)}>\n            <x title='' class=\"${_s.classNames.tagX}\" role='button' aria-label='remove tag'></x>\n            <div>\n                <span class=\"${_s.classNames.tagText}\">${tagData[_s.tagTextProp] || tagData.value}</span>\n            </div>\n        </tag>`;\n    },\n\n    dropdown(settings) {\n      var _sd = settings.dropdown,\n          isManual = _sd.position == 'manual',\n          className = `${settings.classNames.dropdown}`;\n      return `<div class=\"${isManual ? \"\" : className} ${_sd.classname}\" role=\"listbox\" aria-labelledby=\"dropdown\">\n                    <div data-selector='tagify-suggestions-wrapper' class=\"${settings.classNames.dropdownWrapper}\"></div>\n                </div>`;\n    },\n\n    dropdownContent(HTMLContent) {\n      var _s = this.settings,\n          suggestions = this.state.dropdown.suggestions;\n      return `\n            ${_s.templates.dropdownHeader.call(this, suggestions)}\n            ${HTMLContent}\n            ${_s.templates.dropdownFooter.call(this, suggestions)}\n        `;\n    },\n\n    dropdownItem(item) {\n      return `<div ${this.getAttributes(item)}\n                    class='${this.settings.classNames.dropdownItem} ${item.class ? item.class : \"\"}'\n                    tabindex=\"0\"\n                    role=\"option\">${item.mappedValue || item.value}</div>`;\n    },\n\n    /**\r\n     * @param {Array} suggestions An array of all the matched suggested items, including those which were sliced away due to the \"dropdown.maxItems\" setting\r\n     */\n    dropdownHeader(suggestions) {\n      return `<header data-selector='tagify-suggestions-header' class=\"${this.settings.classNames.dropdownHeader}\"></header>`;\n    },\n\n    dropdownFooter(suggestions) {\n      var hasMore = suggestions.length - this.settings.dropdown.maxItems;\n      return hasMore > 0 ? `<footer data-selector='tagify-suggestions-footer' class=\"${this.settings.classNames.dropdownFooter}\">\n                ${hasMore} more items. Refine your search.\n            </footer>` : '';\n    },\n\n    dropdownItemNoMatch: null\n  };\n\n  function EventDispatcher(instance) {\n    // Create a DOM EventTarget object\n    var target = document.createTextNode('');\n\n    function addRemove(op, events, cb) {\n      if (cb) events.split(/\\s+/g).forEach(name => target[op + 'EventListener'].call(target, name, cb));\n    } // Pass EventTarget interface calls to DOM EventTarget object\n\n\n    return {\n      off(events, cb) {\n        addRemove('remove', events, cb);\n        return this;\n      },\n\n      on(events, cb) {\n        if (cb && typeof cb == 'function') addRemove('add', events, cb);\n        return this;\n      },\n\n      trigger(eventName, data, opts) {\n        var e;\n        opts = opts || {\n          cloneData: true\n        };\n        if (!eventName) return;\n\n        if (instance.settings.isJQueryPlugin) {\n          if (eventName == 'remove') eventName = 'removeTag'; // issue #222\n\n          jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data]);\n        } else {\n          try {\n            var eventData = typeof data === 'object' ? data : {\n              value: data\n            };\n            eventData = opts.cloneData ? extend({}, eventData) : eventData;\n            eventData.tagify = this;\n            if (data.event) eventData.event = this.cloneEvent(data.event); // TODO: move the below to the \"extend\" function\n\n            if (data instanceof Object) for (var prop in data) if (data[prop] instanceof HTMLElement) eventData[prop] = data[prop];\n            e = new CustomEvent(eventName, {\n              \"detail\": eventData\n            });\n          } catch (err) {\n            console.warn(err);\n          }\n\n          target.dispatchEvent(e);\n        }\n      }\n\n    };\n  }\n\n  var deleteBackspaceTimeout;\n\n  function triggerChangeEvent() {\n    if (this.settings.mixMode.integrated) return;\n    var inputElm = this.DOM.originalInput,\n        changed = this.state.lastOriginalValueReported !== inputElm.value,\n        event = new CustomEvent(\"change\", {\n      bubbles: true\n    }); // must use \"CustomEvent\" and not \"Event\" to support IE\n\n    if (!changed) return; // must apply this BEFORE triggering the simulated event\n\n    this.state.lastOriginalValueReported = inputElm.value; // React hack: https://github.com/facebook/react/issues/11488\n\n    event.simulated = true;\n    if (inputElm._valueTracker) inputElm._valueTracker.setValue(Math.random());\n    inputElm.dispatchEvent(event); // also trigger a Tagify event\n\n    this.trigger(\"change\", this.state.lastOriginalValueReported); // React, for some reason, clears the input's value after \"dispatchEvent\" is fired\n\n    inputElm.value = this.state.lastOriginalValueReported;\n  }\n\n  var events = {\n    // bind custom events which were passed in the settings\n    customBinding() {\n      this.customEventsList.forEach(name => {\n        this.on(name, this.settings.callbacks[name]);\n      });\n    },\n\n    binding() {\n      let bindUnbind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var _CB = this.events.callbacks,\n          _CBR,\n          action = bindUnbind ? 'addEventListener' : 'removeEventListener'; // do not allow the main events to be bound more than once\n\n\n      if (this.state.mainEvents && bindUnbind) return; // set the binding state of the main events, so they will not be bound more than once\n\n      this.state.mainEvents = bindUnbind; // everything inside gets executed only once-per instance\n\n      if (bindUnbind && !this.listeners.main) {\n        this.events.bindGlobal.call(this);\n        if (this.settings.isJQueryPlugin) jQuery(this.DOM.originalInput).on('tagify.removeAllTags', this.removeAllTags.bind(this));\n      } // setup callback references so events could be removed later\n\n\n      _CBR = this.listeners.main = this.listeners.main || {\n        focus: ['input', _CB.onFocusBlur.bind(this)],\n        keydown: ['input', _CB.onKeydown.bind(this)],\n        click: ['scope', _CB.onClickScope.bind(this)],\n        dblclick: ['scope', _CB.onDoubleClickScope.bind(this)],\n        paste: ['input', _CB.onPaste.bind(this)],\n        drop: ['input', _CB.onDrop.bind(this)],\n        compositionstart: ['input', _CB.onCompositionStart.bind(this)],\n        compositionend: ['input', _CB.onCompositionEnd.bind(this)]\n      };\n\n      for (var eventName in _CBR) {\n        this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);\n      } // listen to original input changes (unfortunetly this is the best way...)\n      // https://stackoverflow.com/a/1949416/104380\n\n\n      clearInterval(this.listeners.main.originalInputValueObserverInterval);\n      this.listeners.main.originalInputValueObserverInterval = setInterval(_CB.observeOriginalInputValue.bind(this), 500); // observers\n\n      var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this)); // cleaup just-in-case\n\n      inputMutationObserver.disconnect(); // observe stuff\n\n      if (this.settings.mode == 'mix') inputMutationObserver.observe(this.DOM.input, {\n        childList: true\n      });\n    },\n\n    bindGlobal(unbind) {\n      var _CB = this.events.callbacks,\n          action = unbind ? 'removeEventListener' : 'addEventListener',\n          e;\n      if (!unbind && this.listeners.global) return; // do not re-bind\n      // these events are global event should never be unbinded, unless the instance is destroyed:\n\n      this.listeners.global = this.listeners && this.listeners.global || [{\n        type: this.isIE ? 'keydown' : 'input',\n        // IE cannot register \"input\" events on contenteditable elements, so the \"keydown\" should be used instead..\n        target: this.DOM.input,\n        cb: _CB[this.isIE ? 'onInputIE' : 'onInput'].bind(this)\n      }, {\n        type: 'keydown',\n        target: window,\n        cb: _CB.onWindowKeyDown.bind(this)\n      }, {\n        type: 'blur',\n        target: this.DOM.input,\n        cb: _CB.onFocusBlur.bind(this)\n      }];\n\n      for (e of this.listeners.global) e.target[action](e.type, e.cb);\n    },\n\n    unbindGlobal() {\n      this.events.bindGlobal.call(this, true);\n    },\n\n    /**\r\n     * DOM events callbacks\r\n     */\n    callbacks: {\n      onFocusBlur(e) {\n        var _this$value, _this$value$;\n\n        var _s = this.settings,\n            text = e.target ? this.trim(e.target.textContent) : '',\n            // a string\n        currentDisplayValue = (_this$value = this.value) === null || _this$value === void 0 ? void 0 : (_this$value$ = _this$value[0]) === null || _this$value$ === void 0 ? void 0 : _this$value$[_s.tagTextProp],\n            type = e.type,\n            ddEnabled = _s.dropdown.enabled >= 0,\n            eventData = {\n          relatedTarget: e.relatedTarget\n        },\n            isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect),\n            isTargetAddNewBtn = this.state.actions.addNew && ddEnabled,\n            isRelatedTargetX = e.relatedTarget && isNodeTag.call(this, e.relatedTarget) && this.DOM.scope.contains(e.relatedTarget),\n            shouldAddTags;\n\n        if (type == 'blur') {\n          if (e.relatedTarget === this.DOM.scope) {\n            this.dropdown.hide();\n            this.DOM.input.focus();\n            return;\n          }\n\n          this.postUpdate();\n          _s.onChangeAfterBlur && this.triggerChangeEvent();\n        }\n\n        if (isTargetSelectOption || isTargetAddNewBtn) return;\n        this.state.hasFocus = type == \"focus\" ? +new Date() : false;\n        this.toggleFocusClass(this.state.hasFocus);\n\n        if (_s.mode == 'mix') {\n          if (type == \"focus\") {\n            this.trigger(\"focus\", eventData);\n          } else if (e.type == \"blur\") {\n            this.trigger(\"blur\", eventData);\n            this.loading(false);\n            this.dropdown.hide(); // reset state which needs reseting\n\n            this.state.dropdown.visible = undefined;\n            this.setStateSelection();\n          }\n\n          return;\n        }\n\n        if (type == \"focus\") {\n          this.trigger(\"focus\", eventData); //  e.target.classList.remove('placeholder');\n\n          if (_s.dropdown.enabled === 0 || !_s.userInput) {\n            // && _s.mode != \"select\"\n            this.dropdown.show(this.value.length ? '' : undefined);\n          }\n\n          return;\n        } else if (type == \"blur\") {\n          this.trigger(\"blur\", eventData);\n          this.loading(false); // when clicking the X button of a selected tag, it is unwanted for it to be added back\n          // again in a few more lines of code (shouldAddTags && addTags)\n\n          if (_s.mode == 'select') {\n            if (isRelatedTargetX) {\n              this.removeTags();\n              text = '';\n            } // if nothing has changed (same display value), do not add a tag\n\n\n            if (currentDisplayValue === text) text = '';\n          }\n\n          shouldAddTags = text && !this.state.actions.selectOption && _s.addTagOnBlur; // do not add a tag if \"selectOption\" action was just fired (this means a tag was just added from the dropdown)\n\n          shouldAddTags && this.addTags(text, true);\n        }\n\n        this.DOM.input.removeAttribute('style');\n        this.dropdown.hide();\n      },\n\n      onCompositionStart(e) {\n        this.state.composing = true;\n      },\n\n      onCompositionEnd(e) {\n        this.state.composing = false;\n      },\n\n      onWindowKeyDown(e) {\n        var focusedElm = document.activeElement,\n            isTag = isNodeTag.call(this, focusedElm),\n            isBelong = isTag && this.DOM.scope.contains(document.activeElement),\n            nextTag;\n        if (!isBelong) return;\n        nextTag = focusedElm.nextElementSibling;\n\n        switch (e.key) {\n          // remove tag if has focus\n          case 'Backspace':\n            {\n              if (!this.settings.readonly) {\n                this.removeTags(focusedElm);\n                (nextTag ? nextTag : this.DOM.input).focus();\n              }\n\n              break;\n            }\n          // edit tag if has focus\n\n          case 'Enter':\n            {\n              setTimeout(this.editTag.bind(this), 0, focusedElm);\n              break;\n            }\n        }\n      },\n\n      onKeydown(e) {\n        var _s = this.settings; // ignore keys during IME composition or when user input is not allowed\n\n        if (this.state.composing || !_s.userInput) return;\n\n        if (_s.mode == 'select' && _s.enforceWhitelist && this.value.length && e.key != 'Tab') {\n          e.preventDefault();\n        }\n\n        var s = this.trim(e.target.textContent);\n        this.trigger(\"keydown\", {\n          event: e\n        });\n        /**\r\n         * ONLY FOR MIX-MODE:\r\n         */\n\n        if (_s.mode == 'mix') {\n          switch (e.key) {\n            case 'Left':\n            case 'ArrowLeft':\n              {\n                // when left arrow was pressed, set a flag so when the dropdown is shown, right-arrow will be ignored\n                // because it seems likely the user wishes to use the arrows to move the caret\n                this.state.actions.ArrowLeft = true;\n                break;\n              }\n\n            case 'Delete':\n            case 'Backspace':\n              {\n                if (this.state.editing) return;\n                var sel = document.getSelection(),\n                    deleteKeyTagDetected = e.key == 'Delete' && sel.anchorOffset == (sel.anchorNode.length || 0),\n                    prevAnchorSibling = sel.anchorNode.previousSibling,\n                    isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling;\n                decode(this.DOM.input.innerHTML);\n                var lastTagElems = this.getTagElms(),\n                    //  isCaretInsideTag = sel.anchorNode.parentNode('.' + _s.classNames.tag),\n                tagBeforeCaret,\n                    tagElmToBeDeleted,\n                    firstTextNodeBeforeTag;\n\n                if (_s.backspace == 'edit' && isCaretAfterTag) {\n                  tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;\n                  setTimeout(this.editTag.bind(this), 0, tagBeforeCaret); // timeout is needed to the last cahacrter in the edited tag won't get deleted\n\n                  e.preventDefault(); // needed so the tag elm won't get deleted\n\n                  return;\n                }\n\n                if (isChromeAndroidBrowser() && isCaretAfterTag instanceof Element) {\n                  firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag);\n                  if (!isCaretAfterTag.hasAttribute('readonly')) isCaretAfterTag.remove(); // since this is Chrome, can safetly use this \"new\" DOM API\n                  // Android-Chrome wrongly hides the keyboard, and loses focus,\n                  // so this hack below is needed to regain focus at the correct place:\n\n                  this.DOM.input.focus();\n                  setTimeout(() => {\n                    this.placeCaretAfterNode(firstTextNodeBeforeTag);\n                    this.DOM.input.click();\n                  });\n                  return;\n                }\n\n                if (sel.anchorNode.nodeName == 'BR') return;\n\n                if ((deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1) {\n                  if (sel.anchorOffset == 0) // caret is at the very begining, before a tag\n                    tagElmToBeDeleted = deleteKeyTagDetected // delete key pressed\n                    ? lastTagElems[0] : null;else tagElmToBeDeleted = lastTagElems[Math.min(lastTagElems.length, sel.anchorOffset) - 1]; // find out if a tag *might* be a candidate for deletion, and if so, which\n                } else if (deleteKeyTagDetected) tagElmToBeDeleted = sel.anchorNode.nextElementSibling;else if (isCaretAfterTag instanceof Element) tagElmToBeDeleted = isCaretAfterTag; // tagElm.hasAttribute('readonly')\n\n\n                if (sel.anchorNode.nodeType == 3 && // node at caret location is a Text node\n                !sel.anchorNode.nodeValue && // has some text\n                sel.anchorNode.previousElementSibling) // text node has a Tag node before it\n                  e.preventDefault(); // if backspace not allowed, do nothing\n                // TODO: a better way to detect if nodes were deleted is to simply check the \"this.value\" before & after\n\n                if ((isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace) {\n                  e.preventDefault();\n                  return;\n                }\n\n                if (sel.type != 'Range' && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != 'Delete') {\n                  e.preventDefault();\n                  return;\n                }\n\n                if (sel.type != 'Range' && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute('readonly')) {\n                  // allows the continuation of deletion by placing the caret on the first previous textNode.\n                  // since a few readonly-tags might be one after the other, iteration is needed:\n                  this.placeCaretAfterNode(getfirstTextNode(tagElmToBeDeleted));\n                  return;\n                } // update regarding https://github.com/yairEO/tagify/issues/762#issuecomment-786464317:\n                // the bug described is more severe than the fix below, therefore I disable the fix until a solution\n                // is found which work well for both cases.\n                // -------\n                // nodeType is \"1\" only when the caret is at the end after last tag (no text after), or before first first (no text before)\n\n                /*\r\n                if( this.isFirefox && sel.anchorNode.nodeType == 1 && sel.anchorOffset != 0 ){\r\n                    this.removeTags() // removes last tag by default if no parameter supplied\r\n                    // place caret inside last textNode, if exist. it's an annoying bug only in FF,\r\n                    // if the last tag is removed, and there is a textNode before it, the caret is not placed at its end\r\n                    this.placeCaretAfterNode( setRangeAtStartEnd(false, this.DOM.input) )\r\n                }\r\n                */\n\n\n                clearTimeout(deleteBackspaceTimeout); // a minimum delay is needed before the node actually gets detached from the document (don't know why),\n                // to know exactly which tag was deleted. This is the easiest way of knowing besides using MutationObserver\n\n                deleteBackspaceTimeout = setTimeout(() => {\n                  var sel = document.getSelection();\n                  decode(this.DOM.input.innerHTML);\n                  !deleteKeyTagDetected && sel.anchorNode.previousSibling; // fixes #384, where the first and only tag will not get removed with backspace\n\n                  /*\r\n                   * [UPDATE DEC 3, 22] SEEMS BELOEW CODE IS NOT NEEDED ANY MORE\r\n                   *\r\n                  if( currentValue.length > lastInputValue.length && prevElm ){\r\n                      if( isNodeTag.call(this, prevElm) && !prevElm.hasAttribute('readonly') ){\r\n                          this.removeTags(prevElm)\r\n                          this.fixFirefoxLastTagNoCaret()\r\n                            // the above \"removeTag\" methods removes the tag with a transition. Chrome adds a <br> element for some reason at this stage\r\n                          if( this.DOM.input.children.length == 2 && this.DOM.input.children[1].tagName == \"BR\" ){\r\n                              this.DOM.input.innerHTML = \"\"\r\n                              this.value.length = 0\r\n                              return true\r\n                          }\r\n                      }\r\n                        else\r\n                          prevElm.remove()\r\n                  }\r\n                  */\n                  // find out which tag(s) were deleted and trigger \"remove\" event\n                  // iterate over the list of tags still in the document and then filter only those from the \"this.value\" collection\n\n                  this.value = [].map.call(lastTagElems, (node, nodeIdx) => {\n                    var tagData = getSetTagData(node); // since readonly cannot be removed (it's technically resurrected if removed somehow)\n\n                    if (node.parentNode || tagData.readonly) return tagData;else this.trigger('remove', {\n                      tag: node,\n                      index: nodeIdx,\n                      data: tagData\n                    });\n                  }).filter(n => n); // remove empty items in the mapped array\n                }, 20); // Firefox needs this higher duration for some reason or things get buggy when deleting text from the end\n\n                break;\n              }\n            // currently commented to allow new lines in mixed-mode\n            // case 'Enter' :\n            //     // e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n          }\n\n          return true;\n        }\n\n        switch (e.key) {\n          case 'Backspace':\n            if (_s.mode == 'select' && _s.enforceWhitelist && this.value.length) this.removeTags();else if (!this.state.dropdown.visible || _s.dropdown.position == 'manual') {\n              if (e.target.textContent == \"\" || s.charCodeAt(0) == 8203) {\n                // 8203: ZERO WIDTH SPACE unicode\n                if (_s.backspace === true) this.removeTags();else if (_s.backspace == 'edit') setTimeout(this.editTag.bind(this), 0); // timeout reason: when edited tag gets focused and the caret is placed at the end, the last character gets deletec (because of backspace)\n              }\n            }\n            break;\n\n          case 'Esc':\n          case 'Escape':\n            if (this.state.dropdown.visible) return;\n            e.target.blur();\n            break;\n\n          case 'Down':\n          case 'ArrowDown':\n            // if( _s.mode == 'select' ) // issue #333\n            if (!this.state.dropdown.visible) this.dropdown.show();\n            break;\n\n          case 'ArrowRight':\n            {\n              let tagData = this.state.inputSuggestion || this.state.ddItemData;\n\n              if (tagData && _s.autoComplete.rightKey) {\n                this.addTags([tagData], true);\n                return;\n              }\n\n              break;\n            }\n\n          case 'Tab':\n            {\n              let selectMode = _s.mode == 'select';\n              if (s && !selectMode) e.preventDefault();else return true;\n            }\n\n          case 'Enter':\n            // manual suggestion boxes are assumed to always be visible\n            if (this.state.dropdown.visible && _s.dropdown.position != 'manual') return;\n            e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n            // because the main \"keydown\" event is bound before the dropdown events, this will fire first and will not *yet*\n            // know if an option was just selected from the dropdown menu. If an option was selected,\n            // the dropdown events should handle adding the tag\n\n            setTimeout(() => {\n              if (this.state.dropdown.visible || this.state.actions.selectOption) return;\n              this.addTags(s, true);\n            });\n        }\n      },\n\n      onInput(e) {\n        this.postUpdate(); // toggles \"tagify--empty\" class\n\n        var _s = this.settings;\n        if (_s.mode == 'mix') return this.events.callbacks.onMixTagsInput.call(this, e);\n        var value = this.input.normalize.call(this),\n            showSuggestions = value.length >= _s.dropdown.enabled,\n            eventData = {\n          value,\n          inputElm: this.DOM.input\n        },\n            validation = this.validateTag({\n          value\n        });\n\n        if (_s.mode == 'select') {\n          this.toggleScopeValidation(validation);\n        }\n\n        eventData.isValid = validation; // for IE; since IE doesn't have an \"input\" event so \"keyDown\" is used instead to trigger the \"onInput\" callback,\n        // and so many keys do not change the input, and for those do not continue.\n\n        if (this.state.inputText == value) return; // save the value on the input's State object\n\n        this.input.set.call(this, value, false); // update the input with the normalized value and run validations\n        // this.setRangeAtStartEnd(false, this.DOM.input); // fix caret position\n        // if delimiters detected, add tags\n\n        if (value.search(_s.delimiters) != -1) {\n          if (this.addTags(value)) {\n            this.input.set.call(this); // clear the input field's value\n          }\n        } else if (_s.dropdown.enabled >= 0) {\n          this.dropdown[showSuggestions ? \"show\" : \"hide\"](value);\n        }\n\n        this.trigger('input', eventData); // \"input\" event must be triggered at this point, before the dropdown is shown\n      },\n\n      onMixTagsInput(e) {\n        var rangeText,\n            match,\n            matchedPatternCount,\n            tag,\n            showSuggestions,\n            selection,\n            _s = this.settings,\n            lastTagsCount = this.value.length,\n            matchFlaggedTag,\n            matchDelimiters,\n            tagsElems = this.getTagElms(),\n            fragment = document.createDocumentFragment(),\n            range = window.getSelection().getRangeAt(0),\n            remainingTagsValues = [].map.call(tagsElems, node => getSetTagData(node).value); // Android Chrome \"keydown\" event argument does not report the correct \"key\".\n        // this workaround is needed to manually call \"onKeydown\" method with a synthesized event object\n\n        if (e.inputType == \"deleteContentBackward\" && isChromeAndroidBrowser()) {\n          this.events.callbacks.onKeydown.call(this, {\n            target: e.target,\n            key: \"Backspace\"\n          });\n        } // re-add \"readonly\" tags which might have been removed\n\n\n        this.value.slice().forEach(item => {\n          if (item.readonly && !remainingTagsValues.includes(item.value)) fragment.appendChild(this.createTagElem(item));\n        });\n\n        if (fragment.childNodes.length) {\n          range.insertNode(fragment);\n          this.setRangeAtStartEnd(false, fragment.lastChild);\n        } // check if tags were \"magically\" added/removed (browser redo/undo or CTRL-A -> delete)\n\n\n        if (tagsElems.length != lastTagsCount) {\n          this.value = [].map.call(this.getTagElms(), node => getSetTagData(node));\n          this.update({\n            withoutChangeEvent: true\n          });\n          return;\n        }\n\n        if (this.hasMaxTags()) return true;\n\n        if (window.getSelection) {\n          selection = window.getSelection(); // only detect tags if selection is inside a textNode (not somehow on already-existing tag)\n\n          if (selection.rangeCount > 0 && selection.anchorNode.nodeType == 3) {\n            range = selection.getRangeAt(0).cloneRange();\n            range.collapse(true);\n            range.setStart(selection.focusNode, 0);\n            rangeText = range.toString().slice(0, range.endOffset); // slice the range so everything AFTER the caret will be trimmed\n            // split = range.toString().split(_s.mixTagsAllowedAfter)  // [\"foo\", \"bar\", \"@baz\"]\n\n            matchedPatternCount = rangeText.split(_s.pattern).length - 1;\n            match = rangeText.match(_s.pattern);\n            if (match) // tag string, example: \"@aaa ccc\"\n              tag = rangeText.slice(rangeText.lastIndexOf(match[match.length - 1]));\n\n            if (tag) {\n              this.state.actions.ArrowLeft = false; // start fresh, assuming the user did not (yet) used any arrow to move the caret\n\n              this.state.tag = {\n                prefix: tag.match(_s.pattern)[0],\n                value: tag.replace(_s.pattern, '') // get rid of the prefix\n\n              };\n              this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length;\n              matchDelimiters = this.state.tag.value.match(_s.delimiters); // if a delimeter exists, add the value as tag (exluding the delimiter)\n\n              if (matchDelimiters) {\n                this.state.tag.value = this.state.tag.value.replace(_s.delimiters, '');\n                this.state.tag.delimiters = matchDelimiters[0];\n                this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect);\n                this.dropdown.hide();\n                return;\n              }\n\n              showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled; // When writeing something that might look like a tag (an email address) but isn't one - it is unwanted\n              // the suggestions dropdown be shown, so the user closes it (in any way), and while continue typing,\n              // dropdown should stay closed until another tag is typed.\n              // if( this.state.tag.value.length && this.state.dropdown.visible === false )\n              //     showSuggestions = false\n              // test for similar flagged tags to the current tag\n\n              try {\n                matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset];\n                matchFlaggedTag = matchFlaggedTag.prefix == this.state.tag.prefix && matchFlaggedTag.value[0] == this.state.tag.value[0]; // reset\n\n                if (this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value) delete this.state.flaggedTags[this.state.tag.baseOffset];\n              } catch (err) {} // scenario: (do not show suggestions of previous matched tag, if more than 1 detected)\n              // (2 tags exist)                          \" a@a.com and @\"\n              // (second tag is removed by backspace)    \" a@a.com and \"\n\n\n              if (matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount) showSuggestions = false;\n            } // no (potential) tag found\n            else {\n                this.state.flaggedTags = {};\n              }\n\n            this.state.mixMode.matchedPatternCount = matchedPatternCount;\n          }\n        } // wait until the \"this.value\" has been updated (see \"onKeydown\" method for \"mix-mode\")\n        // the dropdown must be shown only after this event has been triggered, so an implementer could\n        // dynamically change the whitelist.\n\n\n        setTimeout(() => {\n          this.update({\n            withoutChangeEvent: true\n          });\n          this.trigger(\"input\", extend({}, this.state.tag, {\n            textContent: this.DOM.input.textContent\n          }));\n          if (this.state.tag) this.dropdown[showSuggestions ? \"show\" : \"hide\"](this.state.tag.value);\n        }, 10);\n      },\n\n      onInputIE(e) {\n        var _this = this; // for the \"e.target.textContent\" to be changed, the browser requires a small delay\n\n\n        setTimeout(function () {\n          _this.events.callbacks.onInput.call(_this, e);\n        });\n      },\n\n      observeOriginalInputValue() {\n        // if, for some reason, the Tagified element is no longer in the DOM,\n        // call the \"destroy\" method to kill all references to timeouts/intervals\n        if (!this.DOM.originalInput.parentNode) this.destroy(); // if original input value changed for some reason (for exmaple a form reset)\n\n        if (this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue) this.loadOriginalValues();\n      },\n\n      onClickScope(e) {\n        var _s = this.settings,\n            tagElm = e.target.closest('.' + _s.classNames.tag),\n            timeDiffFocus = +new Date() - this.state.hasFocus;\n\n        if (e.target == this.DOM.scope) {\n          if (!this.state.hasFocus) this.DOM.input.focus();\n          return;\n        } else if (e.target.classList.contains(_s.classNames.tagX)) {\n          this.removeTags(e.target.parentNode);\n          return;\n        } else if (tagElm) {\n          this.trigger(\"click\", {\n            tag: tagElm,\n            index: this.getNodeIndex(tagElm),\n            data: getSetTagData(tagElm),\n            event: e\n          });\n          if (_s.editTags === 1 || _s.editTags.clicks === 1) this.events.callbacks.onDoubleClickScope.call(this, e);\n          return;\n        } // when clicking on the input itself\n        else if (e.target == this.DOM.input) {\n            if (_s.mode == 'mix') {\n              // firefox won't show caret if last element is a tag (and not a textNode),\n              // so an empty textnode should be added\n              this.fixFirefoxLastTagNoCaret();\n            }\n\n            if (timeDiffFocus > 500) {\n              if (this.state.dropdown.visible) this.dropdown.hide();else if (_s.dropdown.enabled === 0 && _s.mode != 'mix') this.dropdown.show(this.value.length ? '' : undefined);\n              return;\n            }\n          }\n\n        if (_s.mode == 'select' && _s.dropdown.enabled === 0 && !this.state.dropdown.visible) this.dropdown.show();\n      },\n\n      // special proccess is needed for pasted content in order to \"clean\" it\n      onPaste(e) {\n        e.preventDefault();\n        var _s = this.settings,\n            selectModeWithoutInput = _s.mode == 'select' && _s.enforceWhitelist;\n\n        if (selectModeWithoutInput || !_s.userInput) {\n          return false;\n        }\n\n        var clipboardData, pastedText;\n        if (_s.readonly) return; // Get pasted data via clipboard API\n\n        clipboardData = e.clipboardData || window.clipboardData;\n        pastedText = clipboardData.getData('Text');\n\n        _s.hooks.beforePaste(e, {\n          tagify: this,\n          pastedText,\n          clipboardData\n        }).then(result => {\n          if (result === undefined) result = pastedText;\n\n          if (result) {\n            this.injectAtCaret(result, window.getSelection().getRangeAt(0));\n\n            if (this.settings.mode == 'mix') {\n              this.events.callbacks.onMixTagsInput.call(this, e);\n            } else if (this.settings.pasteAsTags) {\n              this.addTags(this.state.inputText + result, true);\n            } else this.state.inputText = result;\n          }\n        }).catch(err => err);\n      },\n\n      onDrop(e) {\n        e.preventDefault();\n      },\n\n      onEditTagInput(editableElm, e) {\n        var tagElm = editableElm.closest('.' + this.settings.classNames.tag),\n            tagElmIdx = this.getNodeIndex(tagElm),\n            tagData = getSetTagData(tagElm),\n            textValue = this.input.normalize.call(this, editableElm),\n            dataForChangedProp = {\n          [this.settings.tagTextProp]: textValue,\n          __tagId: tagData.__tagId\n        },\n            // \"__tagId\" is needed so validation will skip current tag when checking for dups\n        isValid = this.validateTag(dataForChangedProp),\n            // the value could have been invalid in the first-place so make sure to re-validate it (via \"addEmptyTag\" method)\n        hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp)); // if the value is same as before-editing and the tag was valid before as well, ignore the  current \"isValid\" result, which is false-positive\n\n        if (!hasChanged && editableElm.originalIsValid === true) isValid = true;\n        tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true);\n        tagData.__isValid = isValid;\n        tagElm.title = isValid === true ? tagData.title || tagData.value : isValid; // change the tag's title to indicate why is the tag invalid (if it's so)\n        // show dropdown if typed text is equal or more than the \"enabled\" dropdown setting\n\n        if (textValue.length >= this.settings.dropdown.enabled) {\n          // this check is needed apparently because doing browser \"undo\" will fire\n          //  \"onEditTagInput\" but \"this.state.editing\" will be \"false\"\n          if (this.state.editing) this.state.editing.value = textValue;\n          this.dropdown.show(textValue);\n        }\n\n        this.trigger(\"edit:input\", {\n          tag: tagElm,\n          index: tagElmIdx,\n          data: extend({}, this.value[tagElmIdx], {\n            newValue: textValue\n          }),\n          event: e\n        });\n      },\n\n      onEditTagPaste(tagElm, e) {\n        // Get pasted data via clipboard API\n        var clipboardData = e.clipboardData || window.clipboardData,\n            pastedText = clipboardData.getData('Text');\n        e.preventDefault();\n        var newNode = injectAtCaret(pastedText);\n        this.setRangeAtStartEnd(false, newNode);\n      },\n\n      onEditTagFocus(tagElm) {\n        this.state.editing = {\n          scope: tagElm,\n          input: tagElm.querySelector(\"[contenteditable]\")\n        };\n      },\n\n      onEditTagBlur(editableElm) {\n        if (!this.state.hasFocus) this.toggleFocusClass(); // one scenario is when selecting a suggestion from the dropdown, when editing, and by selecting it\n        // the \"onEditTagDone\" is called directly, already replacing the tag, so the argument \"editableElm\"\n        // node isn't in the DOM anynmore because it has been replaced.\n\n        if (!this.DOM.scope.contains(editableElm)) return;\n        var _s = this.settings,\n            tagElm = editableElm.closest('.' + _s.classNames.tag),\n            textValue = this.input.normalize.call(this, editableElm),\n            tagData = getSetTagData(tagElm),\n            originalData = tagData.__originalData,\n            // pre-edit data\n        hasChanged = this.editTagChangeDetected(tagData),\n            isValid = this.validateTag({\n          [_s.tagTextProp]: textValue,\n          __tagId: tagData.__tagId\n        }),\n            // \"__tagId\" is needed so validation will skip current tag when checking for dups\n        hasMaxTags,\n            newTagData;\n\n        if (!textValue) {\n          this.onEditTagDone(tagElm);\n          return;\n        } // if nothing changed revert back to how it was before editing\n\n\n        if (!hasChanged) {\n          this.onEditTagDone(tagElm, originalData);\n          return;\n        } // need to know this because if \"keepInvalidTags\" setting is \"true\" and an invalid tag is edited as a valid one,\n        // but the maximum number of tags have alreay been reached, so it should not allow saving the new valid value.\n        // only if the tag was already valid before editing, ignore this check (see a few lines below)\n\n\n        hasMaxTags = this.hasMaxTags();\n        newTagData = extend({}, originalData, {\n          [_s.tagTextProp]: this.trim(textValue),\n          __isValid: isValid\n        }); // pass through optional transformer defined in settings\n\n        _s.transformTag.call(this, newTagData, originalData); // MUST re-validate after tag transformation\n        // only validate the \"tagTextProp\" because is the only thing that metters for validating an edited tag.\n        // -- Scenarios: --\n        // 1. max 3 tags allowd. there are 4 tags, one has invalid input and is edited to a valid one, and now should be marked as \"not allowed\" because limit of tags has reached\n        // 2. max 3 tags allowed. there are 3 tags, one is edited, and so max-tags vaildation should be OK\n\n\n        isValid = (!hasMaxTags || originalData.__isValid === true) && this.validateTag(newTagData);\n\n        if (isValid !== true) {\n          this.trigger(\"invalid\", {\n            data: newTagData,\n            tag: tagElm,\n            message: isValid\n          }); // do nothing if invalid, stay in edit-mode until corrected or reverted by presssing esc\n\n          if (_s.editTags.keepInvalid) return;\n          if (_s.keepInvalidTags) newTagData.__isValid = isValid;else // revert back if not specified to keep\n            newTagData = originalData;\n        } else if (_s.keepInvalidTags) {\n          // cleaup any previous leftovers if the tag was invalid\n          delete newTagData.title;\n          delete newTagData[\"aria-invalid\"];\n          delete newTagData.class;\n        } // tagElm.classList.toggle(_s.classNames.tagInvalid, true)\n\n\n        this.onEditTagDone(tagElm, newTagData);\n      },\n\n      onEditTagkeydown(e, tagElm) {\n        // ignore keys during IME composition\n        if (this.state.composing) return;\n        this.trigger(\"edit:keydown\", {\n          event: e\n        });\n\n        switch (e.key) {\n          case 'Esc':\n          case 'Escape':\n            {\n              // revert the tag to how it was before editing\n              // replace current tag with original one (pre-edited one)\n              tagElm.parentNode.replaceChild(tagElm.__tagifyTagData.__originalHTML, tagElm);\n              this.state.editing = false;\n            }\n\n          case 'Enter':\n          case 'Tab':\n            e.preventDefault();\n            e.target.blur();\n        }\n      },\n\n      onDoubleClickScope(e) {\n        var tagElm = e.target.closest('.' + this.settings.classNames.tag),\n            tagData = getSetTagData(tagElm),\n            _s = this.settings,\n            isEditingTag,\n            isReadyOnlyTag;\n        if (!tagElm || !_s.userInput || tagData.editable === false) return;\n        isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing);\n        isReadyOnlyTag = tagElm.hasAttribute('readonly');\n        if (_s.mode != 'select' && !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags) this.editTag(tagElm);\n        this.toggleFocusClass(true);\n        this.trigger('dblclick', {\n          tag: tagElm,\n          index: this.getNodeIndex(tagElm),\n          data: getSetTagData(tagElm)\n        });\n      },\n\n      /**\r\n       *\r\n       * @param {Object} m an object representing the observed DOM changes\r\n       */\n      onInputDOMChange(m) {\n        // iterate all DOm mutation\n        m.forEach(record => {\n          // only the ADDED nodes\n          record.addedNodes.forEach(addedNode => {\n            // fix chrome's placing '<div><br></div>' everytime ENTER key is pressed, and replace with just `<br'\n            if (addedNode.outerHTML == '<div><br></div>') {\n              addedNode.replaceWith(document.createElement('br'));\n            } // if the added element is a div containing a tag within it (chrome does this when pressing ENTER before a tag)\n            else if (addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector)) {\n                let newlineText = document.createTextNode('');\n                if (addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != 'BR') newlineText = document.createTextNode('\\n'); // unwrap the useless div\n                // chrome adds a BR at the end which should be removed\n\n                addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0, -1)]);\n                this.placeCaretAfterNode(newlineText);\n              } // if this is a tag\n              else if (isNodeTag.call(this, addedNode)) {\n                  var _addedNode$previousSi;\n\n                  if (((_addedNode$previousSi = addedNode.previousSibling) === null || _addedNode$previousSi === void 0 ? void 0 : _addedNode$previousSi.nodeType) == 3 && !addedNode.previousSibling.textContent) addedNode.previousSibling.remove(); // and it is the first node in a new line\n\n                  if (addedNode.previousSibling && addedNode.previousSibling.nodeName == 'BR') {\n                    // allows placing the caret just before the tag, when the tag is the first node in that line\n                    addedNode.previousSibling.replaceWith('\\n\\u200B');\n                    let nextNode = addedNode.nextSibling,\n                        anythingAfterNode = '';\n\n                    while (nextNode) {\n                      anythingAfterNode += nextNode.textContent;\n                      nextNode = nextNode.nextSibling;\n                    } // when hitting ENTER for new line just before an existing tag, but skip below logic when a tag has been addded\n\n\n                    anythingAfterNode.trim() && this.placeCaretAfterNode(addedNode.previousSibling);\n                  }\n                }\n          });\n          record.removedNodes.forEach(removedNode => {\n            // when trying to delete a tag which is in a new line and there's nothing else there (caret is after the tag)\n            if (removedNode && removedNode.nodeName == 'BR' && isNodeTag.call(this, lastInputChild)) {\n              this.removeTags(lastInputChild);\n              this.fixFirefoxLastTagNoCaret();\n            }\n          });\n        }); // get the last child only after the above DOM modifications\n        // check these scenarios:\n        // 1. after a single line, press ENTER once - should add only 1 BR\n        // 2. presss ENTER right before a tag\n        // 3. press enter within a text node before a tag\n\n        var lastInputChild = this.DOM.input.lastChild;\n        if (lastInputChild && lastInputChild.nodeValue == '') lastInputChild.remove(); // make sure the last element is always a BR\n\n        if (!lastInputChild || lastInputChild.nodeName != 'BR') {\n          this.DOM.input.appendChild(document.createElement('br'));\n        }\n      }\n\n    }\n  };\n  /**\r\n   * @constructor\r\n   * @param {Object} input    DOM element\r\n   * @param {Object} settings settings object\r\n   */\n\n  function Tagify(input, settings) {\n    if (!input) {\n      console.warn('Tagify:', 'input element not found', input); // return an empty mock of all methods, so the code using tagify will not break\n      // because it might be calling methods even though the input element does not exist\n\n      const mockInstance = new Proxy(this, {\n        get() {\n          return () => mockInstance;\n        }\n\n      });\n      return mockInstance;\n    }\n\n    if (input.__tagify) {\n      console.warn('Tagify: ', 'input element is already Tagified - Same instance is returned.', input);\n      return input.__tagify;\n    }\n\n    extend(this, EventDispatcher(this));\n    this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent);\n    this.isIE = window.document.documentMode; // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode#Browser_compatibility\n\n    settings = settings || {};\n    this.getPersistedData = getPersistedData(settings.id);\n    this.setPersistedData = setPersistedData(settings.id);\n    this.clearPersistedData = clearPersistedData(settings.id);\n    this.applySettings(input, settings);\n    this.state = {\n      inputText: '',\n      editing: false,\n      composing: false,\n      actions: {},\n      // UI actions for state-locking\n      mixMode: {},\n      dropdown: {},\n      flaggedTags: {} // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here\n\n    };\n    this.value = []; // tags' data\n    // events' callbacks references will be stores here, so events could be unbinded\n\n    this.listeners = {};\n    this.DOM = {}; // Store all relevant DOM elements in an Object\n\n    this.build(input);\n    initDropdown.call(this);\n    this.getCSSVars();\n    this.loadOriginalValues();\n    this.events.customBinding.call(this);\n    this.events.binding.call(this);\n    input.autofocus && this.DOM.input.focus();\n    input.__tagify = this;\n  }\n\n  Tagify.prototype = {\n    _dropdown,\n    helpers: {\n      sameStr,\n      removeCollectionProp,\n      omit,\n      isObject,\n      parseHTML,\n      escapeHTML,\n      extend,\n      concatWithoutDups,\n      getUID,\n      isNodeTag\n    },\n    customEventsList: ['change', 'add', 'remove', 'invalid', 'input', 'click', 'keydown', 'focus', 'blur', 'edit:input', 'edit:beforeUpdate', 'edit:updated', 'edit:start', 'edit:keydown', 'dropdown:show', 'dropdown:hide', 'dropdown:select', 'dropdown:updated', 'dropdown:noMatch', 'dropdown:scroll'],\n    dataProps: ['__isValid', '__removed', '__originalData', '__originalHTML', '__tagId'],\n\n    // internal-uasge props\n    trim(text) {\n      return this.settings.trim && text && typeof text == \"string\" ? text.trim() : text;\n    },\n\n    // expose this handy utility function\n    parseHTML,\n    templates,\n\n    parseTemplate(template, data) {\n      template = this.settings.templates[template] || template;\n      return parseHTML(template.apply(this, data));\n    },\n\n    set whitelist(arr) {\n      const isArray = arr && Array.isArray(arr);\n      this.settings.whitelist = isArray ? arr : [];\n      this.setPersistedData(isArray ? arr : [], 'whitelist');\n    },\n\n    get whitelist() {\n      return this.settings.whitelist;\n    },\n\n    generateClassSelectors(classNames) {\n      for (let name in classNames) {\n        let currentName = name;\n        Object.defineProperty(classNames, currentName + \"Selector\", {\n          get() {\n            return \".\" + this[currentName].split(\" \")[0];\n          }\n\n        });\n      }\n    },\n\n    applySettings(input, settings) {\n      var _settings$dropdown, _settings$dropdown2;\n\n      DEFAULTS.templates = this.templates;\n      var mixModeDefaults = {\n        dropdown: {\n          position: \"text\"\n        }\n      };\n      var mergedDefaults = extend({}, DEFAULTS, settings.mode == 'mix' ? mixModeDefaults : {});\n\n      var _s = this.settings = extend({}, mergedDefaults, settings);\n\n      _s.disabled = input.hasAttribute('disabled');\n      _s.readonly = _s.readonly || input.hasAttribute('readonly');\n      _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\");\n      _s.required = input.hasAttribute('required');\n      this.generateClassSelectors(_s.classNames);\n      if (_s.dropdown.includeSelectedTags === undefined) _s.dropdown.includeSelectedTags = _s.duplicates;\n      if (this.isIE) _s.autoComplete = false; // IE goes crazy if this isn't false\n\n      [\"whitelist\", \"blacklist\"].forEach(name => {\n        var attrVal = input.getAttribute('data-' + name);\n\n        if (attrVal) {\n          attrVal = attrVal.split(_s.delimiters);\n          if (attrVal instanceof Array) _s[name] = attrVal;\n        }\n      }); // backward-compatibility for old version of \"autoComplete\" setting:\n\n      if (\"autoComplete\" in settings && !isObject(settings.autoComplete)) {\n        _s.autoComplete = DEFAULTS.autoComplete;\n        _s.autoComplete.enabled = settings.autoComplete;\n      }\n\n      if (_s.mode == 'mix') {\n        _s.pattern = _s.pattern || /@/;\n        _s.autoComplete.rightKey = true;\n        _s.delimiters = settings.delimiters || null; // default dlimiters in mix-mode must be NULL\n        // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n        // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n        // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n\n        if (_s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp)) _s.dropdown.searchKeys.push(_s.tagTextProp);\n      }\n\n      if (input.pattern) try {\n        _s.pattern = new RegExp(input.pattern);\n      } catch (e) {} // Convert the \"delimiters\" setting into a REGEX object\n\n      if (_s.delimiters) {\n        _s._delimiters = _s.delimiters;\n\n        try {\n          _s.delimiters = new RegExp(this.settings.delimiters, \"g\");\n        } catch (e) {}\n      }\n\n      if (_s.disabled) _s.userInput = false;\n      this.TEXTS = _objectSpread2(_objectSpread2({}, TEXTS), _s.texts || {}); // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\n\n      if (_s.mode == 'select' && !((_settings$dropdown = settings.dropdown) === null || _settings$dropdown === void 0 ? void 0 : _settings$dropdown.enabled) || !_s.userInput) {\n        _s.dropdown.enabled = 0;\n      }\n\n      _s.dropdown.appendTarget = ((_settings$dropdown2 = settings.dropdown) === null || _settings$dropdown2 === void 0 ? void 0 : _settings$dropdown2.appendTarget) || document.body; // get & merge persisted data with current data\n\n      let persistedWhitelist = this.getPersistedData('whitelist');\n      if (Array.isArray(persistedWhitelist)) this.whitelist = Array.isArray(_s.whitelist) ? concatWithoutDups(_s.whitelist, persistedWhitelist) : persistedWhitelist;\n    },\n\n    /**\r\n     * Returns a string of HTML element attributes\r\n     * @param {Object} data [Tag data]\r\n     */\n    getAttributes(data) {\n      var attrs = this.getCustomAttributes(data),\n          s = '',\n          k;\n\n      for (k in attrs) s += \" \" + k + (data[k] !== undefined ? `=\"${attrs[k]}\"` : \"\");\n\n      return s;\n    },\n\n    /**\r\n     * Returns an object of attributes to be used for the templates\r\n     */\n    getCustomAttributes(data) {\n      // only items which are objects have properties which can be used as attributes\n      if (!isObject(data)) return '';\n      var output = {},\n          propName;\n\n      for (propName in data) {\n        if (propName.slice(0, 2) != '__' && propName != 'class' && data.hasOwnProperty(propName) && data[propName] !== undefined) output[propName] = escapeHTML(data[propName]);\n      }\n\n      return output;\n    },\n\n    setStateSelection() {\n      var selection = window.getSelection(); // save last selection place to be able to inject anything from outside to that specific place\n\n      var sel = {\n        anchorOffset: selection.anchorOffset,\n        anchorNode: selection.anchorNode,\n        range: selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)\n      };\n      this.state.selection = sel;\n      return sel;\n    },\n\n    /**\r\n     * Get specific CSS variables which are relevant to this script and parse them as needed.\r\n     * The result is saved on the instance in \"this.CSSVars\"\r\n     */\n    getCSSVars() {\n      var compStyle = getComputedStyle(this.DOM.scope, null);\n\n      const getProp = name => compStyle.getPropertyValue('--' + name);\n\n      function seprateUnitFromValue(a) {\n        if (!a) return {};\n        a = a.trim().split(' ')[0];\n        var unit = a.split(/\\d+/g).filter(n => n).pop().trim(),\n            value = +a.split(unit).filter(n => n)[0].trim();\n        return {\n          value,\n          unit\n        };\n      }\n\n      this.CSSVars = {\n        tagHideTransition: (_ref => {\n          let value = _ref.value,\n              unit = _ref.unit;\n          return unit == 's' ? value * 1000 : value;\n        })(seprateUnitFromValue(getProp('tag-hide-transition')))\n      };\n    },\n\n    /**\r\n     * builds the HTML of this component\r\n     * @param  {Object} input [DOM element which would be \"transformed\" into \"Tags\"]\r\n     */\n    build(input) {\n      var DOM = this.DOM;\n\n      if (this.settings.mixMode.integrated) {\n        DOM.originalInput = null;\n        DOM.scope = input;\n        DOM.input = input;\n      } else {\n        DOM.originalInput = input;\n        DOM.originalInput_tabIndex = input.tabIndex;\n        DOM.scope = this.parseTemplate('wrapper', [input, this.settings]);\n        DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector);\n        input.parentNode.insertBefore(DOM.scope, input);\n        input.tabIndex = -1; // do not allow focus or typing directly, once tagified\n      }\n    },\n\n    /**\r\n     * revert any changes made by this component\r\n     */\n    destroy() {\n      this.events.unbindGlobal.call(this);\n      this.DOM.scope.parentNode.removeChild(this.DOM.scope);\n      this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex;\n      delete this.DOM.originalInput.__tagify;\n      this.dropdown.hide(true);\n      clearTimeout(this.dropdownHide__bindEventsTimeout);\n      clearInterval(this.listeners.main.originalInputValueObserverInterval);\n    },\n\n    /**\r\n     * if the original input has any values, add them as tags\r\n     */\n    loadOriginalValues(value) {\n      var lastChild,\n          _s = this.settings; // temporarily block firign the \"change\" event on the original input unil\n      // this method finish removing current value and adding the new one\n\n      this.state.blockChangeEvent = true;\n\n      if (value === undefined) {\n        const persistedOriginalValue = this.getPersistedData('value'); // if the field already has a field, trust its the desired\n        // one to be rendered and do not use the persisted one\n\n        if (persistedOriginalValue && !this.DOM.originalInput.value) value = persistedOriginalValue;else value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;\n      }\n\n      this.removeAllTags();\n\n      if (value) {\n        if (_s.mode == 'mix') {\n          this.parseMixTags(value);\n          lastChild = this.DOM.input.lastChild; // fixes a Chrome bug, when the last node in `mix-mode` is a tag, the caret appears at the far-top-top, outside the field\n\n          if (!lastChild || lastChild.tagName != 'BR') this.DOM.input.insertAdjacentHTML('beforeend', '<br>');\n        } else {\n          try {\n            if (JSON.parse(value) instanceof Array) value = JSON.parse(value);\n          } catch (err) {}\n\n          this.addTags(value, true).forEach(tag => tag && tag.classList.add(_s.classNames.tagNoAnimation));\n        }\n      } else this.postUpdate();\n\n      this.state.lastOriginalValueReported = _s.mixMode.integrated ? '' : this.DOM.originalInput.value;\n      this.state.blockChangeEvent = false;\n    },\n\n    cloneEvent(e) {\n      var clonedEvent = {};\n\n      for (var v in e) if (v != 'path') clonedEvent[v] = e[v];\n\n      return clonedEvent;\n    },\n\n    /**\r\n     * Toogle global loading state on/off\r\n     * Useful when fetching async whitelist while user is typing\r\n     * @param {Boolean} isLoading\r\n     */\n    loading(isLoading) {\n      this.state.isLoading = isLoading; // IE11 doesn't support toggle with second parameter\n\n      this.DOM.scope.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.scopeLoading);\n      return this;\n    },\n\n    /**\r\n     * Toogle a tag loading state on/off\r\n     * @param {Boolean} isLoading\r\n     */\n    tagLoading(tagElm, isLoading) {\n      if (tagElm) // IE11 doesn't support toggle with second parameter\n        tagElm.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.tagLoading);\n      return this;\n    },\n\n    /**\r\n     * Toggles class on the main tagify container (\"scope\")\r\n     * @param {String} className\r\n     * @param {Boolean} force\r\n     */\n    toggleClass(className, force) {\n      if (typeof className == 'string') this.DOM.scope.classList.toggle(className, force);\n    },\n\n    toggleScopeValidation(validation) {\n      var isValid = validation === true || validation === undefined; // initially it is undefined\n\n      if (!this.settings.required && validation && validation === this.TEXTS.empty) isValid = true;\n      this.toggleClass(this.settings.classNames.tagInvalid, !isValid);\n      this.DOM.scope.title = isValid ? '' : validation;\n    },\n\n    toggleFocusClass(force) {\n      this.toggleClass(this.settings.classNames.focus, !!force);\n    },\n\n    triggerChangeEvent,\n    events,\n\n    fixFirefoxLastTagNoCaret() {\n      return; // seems to be fixed in newer version of FF, so retiring below code (for now)\n      // var inputElm = this.DOM.input\n      // if( this.isFirefox && inputElm.childNodes.length && inputElm.lastChild.nodeType == 1 ){\n      //     inputElm.appendChild(document.createTextNode(\"\\u200b\"))\n      //     this.setRangeAtStartEnd(true, inputElm)\n      //     return true\n      // }\n    },\n\n    /** https://stackoverflow.com/a/59156872/104380\r\n     * @param {Boolean} start indicating where to place it (start or end of the node)\r\n     * @param {Object}  node  DOM node to place the caret at\r\n     */\n    setRangeAtStartEnd(start, node) {\n      if (!node) return;\n      start = typeof start == 'number' ? start : !!start;\n      node = node.lastChild || node;\n      var sel = document.getSelection(); // do not force caret placement if the current selection (focus) is on another element (not this tagify instance)\n\n      if (sel.focusNode instanceof Element && !this.DOM.input.contains(sel.focusNode)) {\n        return true;\n      }\n\n      try {\n        if (sel.rangeCount >= 1) {\n          ['Start', 'End'].forEach(pos => sel.getRangeAt(0)[\"set\" + pos](node, start ? start : node.length));\n        }\n      } catch (err) {// console.warn(\"Tagify: \", err)\n      }\n    },\n\n    placeCaretAfterNode(node) {\n      if (!node || !node.parentNode) return;\n      var nextSibling = node,\n          sel = window.getSelection(),\n          range = sel.getRangeAt(0);\n\n      if (sel.rangeCount) {\n        range.setStartAfter(nextSibling);\n        range.collapse(true); // range.setEndBefore(nextSibling || node);\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n      }\n    },\n\n    insertAfterTag(tagElm, newNode) {\n      newNode = newNode || this.settings.mixMode.insertAfterTag;\n      if (!tagElm || !tagElm.parentNode || !newNode) return;\n      newNode = typeof newNode == 'string' ? document.createTextNode(newNode) : newNode;\n      tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling);\n      return newNode;\n    },\n\n    // compares all \"__originalData\" property values with the current \"tagData\" properties\n    // and returns \"true\" if something changed.\n    editTagChangeDetected(tagData) {\n      var originalData = tagData.__originalData;\n\n      for (var prop in originalData) if (!this.dataProps.includes(prop) && tagData[prop] != originalData[prop]) return true;\n\n      return false; // not changed\n    },\n\n    // returns the node which has the actual tag's content\n    getTagTextNode(tagElm) {\n      return tagElm.querySelector(this.settings.classNames.tagTextSelector);\n    },\n\n    // sets the text of a tag\n    setTagTextNode(tagElm, HTML) {\n      this.getTagTextNode(tagElm).innerHTML = escapeHTML(HTML);\n    },\n\n    /**\r\n     * Enters a tag into \"edit\" mode\r\n     * @param {Node} tagElm the tag element to edit. if nothing specified, use last last\r\n     */\n    editTag(tagElm, opts) {\n      tagElm = tagElm || this.getLastTag();\n      opts = opts || {};\n      this.dropdown.hide();\n\n      var _s = this.settings,\n          editableElm = this.getTagTextNode(tagElm),\n          tagIdx = this.getNodeIndex(tagElm),\n          tagData = getSetTagData(tagElm),\n          _CB = this.events.callbacks,\n          that = this,\n          isValid = true,\n          delayed_onEditTagBlur = function () {\n        setTimeout(() => _CB.onEditTagBlur.call(that, that.getTagTextNode(tagElm)));\n      };\n\n      if (!editableElm) {\n        console.warn('Cannot find element in Tag template: .', _s.classNames.tagTextSelector);\n        return;\n      }\n\n      if (tagData instanceof Object && \"editable\" in tagData && !tagData.editable) return; // cache the original data, on the DOM node, before any modification ocurs, for possible revert\n\n      tagData = getSetTagData(tagElm, {\n        __originalData: extend({}, tagData),\n        __originalHTML: tagElm.cloneNode(true)\n      }); // re-set the tagify custom-prop on the clones element (because cloning removed it)\n\n      getSetTagData(tagData.__originalHTML, tagData.__originalData);\n      editableElm.setAttribute('contenteditable', true);\n      tagElm.classList.add(_s.classNames.tagEditing);\n      editableElm.addEventListener('focus', _CB.onEditTagFocus.bind(this, tagElm));\n      editableElm.addEventListener('blur', delayed_onEditTagBlur);\n      editableElm.addEventListener('input', _CB.onEditTagInput.bind(this, editableElm));\n      editableElm.addEventListener('paste', _CB.onEditTagPaste.bind(this, editableElm));\n      editableElm.addEventListener('keydown', e => _CB.onEditTagkeydown.call(this, e, tagElm));\n      editableElm.addEventListener('compositionstart', _CB.onCompositionStart.bind(this));\n      editableElm.addEventListener('compositionend', _CB.onCompositionEnd.bind(this));\n      if (!opts.skipValidation) isValid = this.editTagToggleValidity(tagElm);\n      editableElm.originalIsValid = isValid;\n      this.trigger(\"edit:start\", {\n        tag: tagElm,\n        index: tagIdx,\n        data: tagData,\n        isValid\n      });\n      editableElm.focus();\n      this.setRangeAtStartEnd(false, editableElm); // place the caret at the END of the editable tag text\n\n      return this;\n    },\n\n    /**\r\n     * If a tag is invalid, for any reason, set its class to \"not allowed\" (see defaults file)\r\n     * @param {Node} tagElm required\r\n     * @param {Object} tagData optional\r\n     * @returns true if valid, a string (reason) if not\r\n     */\n    editTagToggleValidity(tagElm, tagData) {\n      var tagData = tagData || getSetTagData(tagElm),\n          isValid;\n\n      if (!tagData) {\n        console.warn(\"tag has no data: \", tagElm, tagData);\n        return;\n      }\n\n      isValid = !(\"__isValid\" in tagData) || tagData.__isValid === true;\n\n      if (!isValid) {\n        this.removeTagsFromValue(tagElm);\n      }\n\n      this.update(); //this.validateTag(tagData);\n\n      tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid);\n      return tagData.__isValid;\n    },\n\n    onEditTagDone(tagElm, tagData) {\n      tagElm = tagElm || this.state.editing.scope;\n      tagData = tagData || {};\n      var eventData = {\n        tag: tagElm,\n        index: this.getNodeIndex(tagElm),\n        previousData: getSetTagData(tagElm),\n        data: tagData\n      };\n      this.trigger(\"edit:beforeUpdate\", eventData, {\n        cloneData: false\n      });\n      this.state.editing = false;\n      delete tagData.__originalData;\n      delete tagData.__originalHTML;\n\n      if (tagElm && tagData[this.settings.tagTextProp]) {\n        tagElm = this.replaceTag(tagElm, tagData);\n        this.editTagToggleValidity(tagElm, tagData);\n        if (this.settings.a11y.focusableTags) tagElm.focus();else // place caret after edited tag\n          this.placeCaretAfterNode(tagElm);\n      } else if (tagElm) this.removeTags(tagElm);\n\n      this.trigger(\"edit:updated\", eventData);\n      this.dropdown.hide(); // check if any of the current tags which might have been marked as \"duplicate\" should be now un-marked\n\n      if (this.settings.keepInvalidTags) this.reCheckInvalidTags();\n    },\n\n    /**\r\n     * Replaces an exisitng tag with a new one. Used for updating a tag's data\r\n     * @param {Object} tagElm  [DOM node to replace]\r\n     * @param {Object} tagData [data to create new tag from]\r\n     */\n    replaceTag(tagElm, tagData) {\n      if (!tagData || !tagData.value) tagData = tagElm.__tagifyTagData; // if tag is invalid, make the according changes in the newly created element\n\n      if (tagData.__isValid && tagData.__isValid != true) extend(tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid));\n      var newTagElm = this.createTagElem(tagData); // update DOM\n\n      tagElm.parentNode.replaceChild(newTagElm, tagElm);\n      this.updateValueByDOMTags();\n      return newTagElm;\n    },\n\n    /**\r\n     * update \"value\" (Array of Objects) by traversing all valid tags\r\n     */\n    updateValueByDOMTags() {\n      this.value.length = 0;\n      [].forEach.call(this.getTagElms(), node => {\n        if (node.classList.contains(this.settings.classNames.tagNotAllowed.split(' ')[0])) return;\n        this.value.push(getSetTagData(node));\n      });\n      this.update();\n    },\n\n    /**\r\n     * injects nodes/text at caret position, which is saved on the \"state\" when \"blur\" event gets triggered\r\n     * @param {Node} injectedNode [the node to inject at the caret position]\r\n     * @param {Object} selection [optional range Object. must have \"anchorNode\" & \"anchorOffset\"]\r\n     */\n    injectAtCaret(injectedNode, range) {\n      var _this$state$selection;\n\n      range = range || ((_this$state$selection = this.state.selection) === null || _this$state$selection === void 0 ? void 0 : _this$state$selection.range);\n\n      if (!range && injectedNode) {\n        this.appendMixTags(injectedNode);\n        return this;\n      }\n\n      injectAtCaret(injectedNode, range);\n      this.setRangeAtStartEnd(false, injectedNode);\n      this.updateValueByDOMTags(); // updates internal \"this.value\"\n\n      this.update(); // updates original input/textarea\n\n      return this;\n    },\n\n    /**\r\n     * input bridge for accessing & setting\r\n     * @type {Object}\r\n     */\n    input: {\n      set() {\n        let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        let updateDOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var hideDropdown = this.settings.dropdown.closeOnSelect;\n        this.state.inputText = s;\n        if (updateDOM) this.DOM.input.innerHTML = escapeHTML(\"\" + s);\n        if (!s && hideDropdown) this.dropdown.hide.bind(this);\n        this.input.autocomplete.suggest.call(this);\n        this.input.validate.call(this);\n      },\n\n      raw() {\n        return this.DOM.input.textContent;\n      },\n\n      /**\r\n       * Marks the tagify's input as \"invalid\" if the value did not pass \"validateTag()\"\r\n       */\n      validate() {\n        var isValid = !this.state.inputText || this.validateTag({\n          value: this.state.inputText\n        }) === true;\n        this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid);\n        return isValid;\n      },\n\n      // remove any child DOM elements that aren't of type TEXT (like <br>)\n      normalize(node) {\n        var clone = node || this.DOM.input,\n            //.cloneNode(true),\n        v = []; // when a text was pasted in FF, the \"this.DOM.input\" element will have <br> but no newline symbols (\\n), and this will\n        // result in tags not being properly created if one wishes to create a separate tag per newline.\n\n        clone.childNodes.forEach(n => n.nodeType == 3 && v.push(n.nodeValue));\n        v = v.join(\"\\n\");\n\n        try {\n          // \"delimiters\" might be of a non-regex value, where this will fail (\"Tags With Properties\" example in demo page):\n          v = v.replace(/(?:\\r\\n|\\r|\\n)/g, this.settings.delimiters.source.charAt(0));\n        } catch (err) {}\n\n        v = v.replace(/\\s/g, ' '); // replace NBSPs with spaces characters\n\n        return this.trim(v);\n      },\n\n      /**\r\n       * suggest the rest of the input's value (via CSS \"::after\" using \"content:attr(...)\")\r\n       * @param  {String} s [description]\r\n       */\n      autocomplete: {\n        suggest(data) {\n          if (!this.settings.autoComplete.enabled) return;\n          data = data || {\n            value: ''\n          };\n          if (typeof data == 'string') data = {\n            value: data\n          };\n          var suggestedText = this.dropdown.getMappedValue(data);\n          if (typeof suggestedText === 'number') return;\n          var suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(),\n              suggestionTrimmed = suggestedText.substring(this.state.inputText.length);\n\n          if (!suggestedText || !this.state.inputText || suggestionStart != this.state.inputText.toLowerCase()) {\n            this.DOM.input.removeAttribute(\"data-suggest\");\n            delete this.state.inputSuggestion;\n          } else {\n            this.DOM.input.setAttribute(\"data-suggest\", suggestionTrimmed);\n            this.state.inputSuggestion = data;\n          }\n        },\n\n        /**\r\n         * sets the suggested text as the input's value & cleanup the suggestion autocomplete.\r\n         * @param {String} s [text]\r\n         */\n        set(s) {\n          var dataSuggest = this.DOM.input.getAttribute('data-suggest'),\n              suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);\n\n          if (suggestion) {\n            if (this.settings.mode == 'mix') {\n              this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + suggestion));\n            } else {\n              this.input.set.call(this, suggestion);\n              this.setRangeAtStartEnd(false, this.DOM.input);\n            }\n\n            this.input.autocomplete.suggest.call(this);\n            this.dropdown.hide();\n            return true;\n          }\n\n          return false;\n        }\n\n      }\n    },\n\n    /**\r\n     * returns the index of the the tagData within the \"this.value\" array collection.\r\n     * since values should be unique, it is suffice to only search by \"value\" property\r\n     * @param {Object} tagData\r\n     */\n    getTagIdx(tagData) {\n      return this.value.findIndex(item => item.__tagId == (tagData || {}).__tagId);\n    },\n\n    getNodeIndex(node) {\n      var index = 0;\n      if (node) while (node = node.previousElementSibling) index++;\n      return index;\n    },\n\n    getTagElms() {\n      for (var _len = arguments.length, classess = new Array(_len), _key = 0; _key < _len; _key++) {\n        classess[_key] = arguments[_key];\n      }\n\n      var classname = '.' + [...this.settings.classNames.tag.split(' '), ...classess].join('.');\n      return [].slice.call(this.DOM.scope.querySelectorAll(classname)); // convert nodeList to Array - https://stackoverflow.com/a/3199627/104380\n    },\n\n    /**\r\n     * gets the last non-readonly, not-in-the-proccess-of-removal tag\r\n     */\n    getLastTag() {\n      var lastTag = this.DOM.scope.querySelectorAll(`${this.settings.classNames.tagSelector}:not(.${this.settings.classNames.tagHide}):not([readonly])`);\n      return lastTag[lastTag.length - 1];\n    },\n\n    /**\r\n     * Searches if any tag with a certain value already exis\r\n     * @param  {String/Object} value [text value / tag data object]\r\n     * @param  {Boolean} caseSensitive\r\n     * @return {Number}\r\n     */\n    isTagDuplicate(value, caseSensitive, tagId) {\n      var dupsCount = 0,\n          _s = this.settings; // duplications are irrelevant for this scenario\n\n      if (_s.mode == 'select') return false;\n\n      for (let item of this.value) {\n        let isSameStr = sameStr(this.trim(\"\" + value), item.value, caseSensitive);\n        if (isSameStr && tagId != item.__tagId) dupsCount++;\n      }\n\n      return dupsCount;\n    },\n\n    getTagIndexByValue(value) {\n      var indices = [];\n      this.getTagElms().forEach((tagElm, i) => {\n        if (sameStr(this.trim(tagElm.textContent), value, this.settings.dropdown.caseSensitive)) indices.push(i);\n      });\n      return indices;\n    },\n\n    getTagElmByValue(value) {\n      var tagIdx = this.getTagIndexByValue(value)[0];\n      return this.getTagElms()[tagIdx];\n    },\n\n    /**\r\n     * Temporarily marks a tag element (by value or Node argument)\r\n     * @param  {Object} tagElm [a specific \"tag\" element to compare to the other tag elements siblings]\r\n     */\n    flashTag(tagElm) {\n      if (tagElm) {\n        tagElm.classList.add(this.settings.classNames.tagFlash);\n        setTimeout(() => {\n          tagElm.classList.remove(this.settings.classNames.tagFlash);\n        }, 100);\n      }\n    },\n\n    /**\r\n     * checks if text is in the blacklist\r\n     */\n    isTagBlacklisted(v) {\n      v = this.trim(v.toLowerCase());\n      return this.settings.blacklist.filter(x => (\"\" + x).toLowerCase() == v).length;\n    },\n\n    /**\r\n     * checks if text is in the whitelist\r\n     */\n    isTagWhitelisted(v) {\n      return !!this.getWhitelistItem(v);\n      /*\r\n      return this.settings.whitelist.some(item =>\r\n          typeof v == 'string'\r\n              ? sameStr(this.trim(v), (item.value || item))\r\n              : sameStr(JSON.stringify(item), JSON.stringify(v))\r\n      )\r\n      */\n    },\n\n    /**\r\n     * Returns the first whitelist item matched, by value (if match found)\r\n     * @param {String} value [text to match by]\r\n     */\n    getWhitelistItem(value, prop, whitelist) {\n      var result,\n          prop = prop || 'value',\n          _s = this.settings,\n          whitelist = whitelist || _s.whitelist;\n      whitelist.some(_wi => {\n        var _wiv = typeof _wi == 'string' ? _wi : _wi[prop] || _wi.value,\n            isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim);\n\n        if (isSameStr) {\n          result = typeof _wi == 'string' ? {\n            value: _wi\n          } : _wi;\n          return true;\n        }\n      }); // first iterate the whitelist, try find matches by \"value\" and if that fails\n      // and a \"tagTextProp\" is set to be other than \"value\", try that also\n\n      if (!result && prop == 'value' && _s.tagTextProp != 'value') {\n        // if found, adds the first which matches\n        result = this.getWhitelistItem(value, _s.tagTextProp, whitelist);\n      }\n\n      return result;\n    },\n\n    /**\r\n     * validate a tag object BEFORE the actual tag will be created & appeneded\r\n     * @param  {String} s\r\n     * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]\r\n     * @return {Boolean/String}  [\"true\" if validation has passed, String for a fail]\r\n     */\n    validateTag(tagData) {\n      var _s = this.settings,\n          // when validating a tag in edit-mode, need to take \"tagTextProp\" into consideration\n      prop = \"value\" in tagData ? \"value\" : _s.tagTextProp,\n          v = this.trim(tagData[prop] + \"\"); // check for definitive empty value\n\n      if (!(tagData[prop] + \"\").trim()) return this.TEXTS.empty; // check if pattern should be used and if so, use it to test the value\n\n      if (_s.pattern && _s.pattern instanceof RegExp && !_s.pattern.test(v)) return this.TEXTS.pattern; // check for duplicates\n\n      if (!_s.duplicates && this.isTagDuplicate(v, _s.dropdown.caseSensitive, tagData.__tagId)) return this.TEXTS.duplicate;\n      if (this.isTagBlacklisted(v) || _s.enforceWhitelist && !this.isTagWhitelisted(v)) return this.TEXTS.notAllowed;\n      if (_s.validate) return _s.validate(tagData);\n      return true;\n    },\n\n    getInvalidTagAttrs(tagData, validation) {\n      return {\n        \"aria-invalid\": true,\n        \"class\": `${tagData.class || ''} ${this.settings.classNames.tagNotAllowed}`.trim(),\n        \"title\": validation\n      };\n    },\n\n    hasMaxTags() {\n      return this.value.length >= this.settings.maxTags ? this.TEXTS.exceed : false;\n    },\n\n    setReadonly(toggle, attrribute) {\n      var _s = this.settings;\n      document.activeElement.blur(); // exit possible edit-mode\n\n      _s[attrribute || 'readonly'] = toggle;\n      this.DOM.scope[(toggle ? 'set' : 'remove') + 'Attribute'](attrribute || 'readonly', true);\n      this.setContentEditable(!toggle);\n    },\n\n    setContentEditable(state) {\n      if (!this.settings.userInput) return;\n      this.DOM.input.contentEditable = state;\n      this.DOM.input.tabIndex = !!state ? 0 : -1;\n    },\n\n    setDisabled(isDisabled) {\n      this.setReadonly(isDisabled, 'disabled');\n    },\n\n    /**\r\n     * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words\r\n     * so each item should be iterated on and a tag created for.\r\n     * @return {Array} [Array of Objects]\r\n     */\n    normalizeTags(tagsItems) {\n      var _this$settings = this.settings,\n          whitelist = _this$settings.whitelist,\n          delimiters = _this$settings.delimiters,\n          mode = _this$settings.mode,\n          tagTextProp = _this$settings.tagTextProp,\n          whitelistMatches = [],\n          whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false,\n          isArray = Array.isArray(tagsItems),\n          isCollection = isArray && tagsItems[0].value,\n          mapStringToCollection = s => (s + \"\").split(delimiters).filter(n => n).map(v => ({\n        [tagTextProp]: this.trim(v),\n        value: this.trim(v)\n      }));\n\n      if (typeof tagsItems == 'number') tagsItems = tagsItems.toString(); // if the argument is a \"simple\" String, ex: \"aaa, bbb, ccc\"\n\n      if (typeof tagsItems == 'string') {\n        if (!tagsItems.trim()) return []; // go over each tag and add it (if there were multiple ones)\n\n        tagsItems = mapStringToCollection(tagsItems);\n      } // if is an Array of Strings, convert to an Array of Objects\n      else if (isArray) {\n          // flatten the 2D array\n          tagsItems = [].concat(...tagsItems.map(item => item.value ? item // mapStringToCollection(item.value).map(newItem => ({...item,...newItem}))\n          : mapStringToCollection(item)));\n        } // search if the tag exists in the whitelist as an Object (has props),\n      // to be able to use its properties.\n      // skip matching collections with whitelist items as they are considered \"whole\"\n\n\n      if (whitelistWithProps && !isCollection) {\n        tagsItems.forEach(item => {\n          var whitelistMatchesValues = whitelistMatches.map(a => a.value); // if suggestions are shown, they are already filtered, so it's easier to use them,\n          // because the whitelist might also include items which have already been added\n\n          var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], {\n            exact: true\n          });\n          if (!this.settings.duplicates) // also filter out items which have already been matched in previous iterations\n            filteredList = filteredList.filter(filteredItem => !whitelistMatchesValues.includes(filteredItem.value)); // get the best match out of list of possible matches.\n          // if there was a single item in the filtered list, use that one\n\n          var matchObj = filteredList.length > 1 ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList) : filteredList[0];\n\n          if (matchObj && matchObj instanceof Object) {\n            whitelistMatches.push(matchObj); // set the Array (with the found Object) as the new value\n          } else if (mode != 'mix') {\n            if (item.value == undefined) item.value = item[tagTextProp];\n            whitelistMatches.push(item);\n          }\n        });\n        if (whitelistMatches.length) tagsItems = whitelistMatches;\n      }\n\n      return tagsItems;\n    },\n\n    /**\r\n     * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags\r\n     * https://stackoverflow.com/a/57598892/104380\r\n     * @param {String} s\r\n     */\n    parseMixTags(s) {\n      var _this$settings2 = this.settings,\n          mixTagsInterpolator = _this$settings2.mixTagsInterpolator,\n          duplicates = _this$settings2.duplicates,\n          transformTag = _this$settings2.transformTag,\n          enforceWhitelist = _this$settings2.enforceWhitelist,\n          maxTags = _this$settings2.maxTags,\n          tagTextProp = _this$settings2.tagTextProp,\n          tagsDataSet = [];\n      s = s.split(mixTagsInterpolator[0]).map((s1, i) => {\n        var s2 = s1.split(mixTagsInterpolator[1]),\n            preInterpolated = s2[0],\n            maxTagsReached = tagsDataSet.length == maxTags,\n            textProp,\n            tagData,\n            tagElm;\n\n        try {\n          // skip numbers and go straight to the \"catch\" statement\n          if (preInterpolated == +preInterpolated) throw Error;\n          tagData = JSON.parse(preInterpolated);\n        } catch (err) {\n          tagData = this.normalizeTags(preInterpolated)[0] || {\n            value: preInterpolated\n          };\n        }\n\n        transformTag.call(this, tagData);\n\n        if (!maxTagsReached && s2.length > 1 && (!enforceWhitelist || this.isTagWhitelisted(tagData.value)) && !(!duplicates && this.isTagDuplicate(tagData.value))) {\n          // in case \"tagTextProp\" setting is set to other than \"value\" and this tag does not have this prop\n          textProp = tagData[tagTextProp] ? tagTextProp : 'value';\n          tagData[textProp] = this.trim(tagData[textProp]);\n          tagElm = this.createTagElem(tagData);\n          tagsDataSet.push(tagData);\n          tagElm.classList.add(this.settings.classNames.tagNoAnimation);\n          s2[0] = tagElm.outerHTML; //+ \"&#8288;\"  // put a zero-space at the end so the caret won't jump back to the start (when the last input's child element is a tag)\n\n          this.value.push(tagData);\n        } else if (s1) return i ? mixTagsInterpolator[0] + s1 : s1;\n\n        return s2.join('');\n      }).join('');\n      this.DOM.input.innerHTML = s;\n      this.DOM.input.appendChild(document.createTextNode(''));\n      this.DOM.input.normalize();\n      this.getTagElms().forEach((elm, idx) => getSetTagData(elm, tagsDataSet[idx]));\n      this.update({\n        withoutChangeEvent: true\n      });\n      return s;\n    },\n\n    /**\r\n     * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)\r\n     * First there *has* to be a \"this.state.tag\" which is a string that was just typed and is staring with a prefix\r\n     */\n    replaceTextWithNode(newWrapperNode, strToReplace) {\n      if (!this.state.tag && !strToReplace) return;\n      strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;\n      var idx,\n          nodeToReplace,\n          selection = this.state.selection || window.getSelection(),\n          nodeAtCaret = selection.anchorNode,\n          firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0; // STEP 1: ex. replace #ba with the tag \"bart\" where \"|\" is where the caret is:\n      // CURRENT STATE: \"foo #ba #ba| #ba\"\n      // split the text node at the index of the caret\n\n      nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset); // node 0: \"foo #ba #ba|\"\n      // node 1: \" #ba\"\n      // get index of LAST occurence of \"#ba\"\n\n      idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace);\n      if (idx == -1) return true;\n      nodeToReplace = nodeAtCaret.splitText(idx); // node 0: \"foo #ba \"\n      // node 1: \"#ba\"    <- nodeToReplace\n\n      newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace); // must NOT normalize contenteditable or it will cause unwanted issues:\n      // https://monosnap.com/file/ZDVmRvq5upYkidiFedvrwzSswegWk7\n      // nodeAtCaret.parentNode.normalize()\n\n      return true;\n    },\n\n    /**\r\n     * For selecting a single option (not used for multiple tags, but for \"mode:select\" only)\r\n     * @param {Object} tagElm   Tag DOM node\r\n     * @param {Object} tagData  Tag data\r\n     */\n    selectTag(tagElm, tagData) {\n      var _s = this.settings;\n      if (_s.enforceWhitelist && !this.isTagWhitelisted(tagData.value)) return;\n      this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true); // place the caret at the end of the input, only if a dropdown option was selected (and not by manually typing another value and clicking \"TAB\")\n\n      if (this.state.actions.selectOption) setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input));\n      var lastTagElm = this.getLastTag();\n      if (lastTagElm) this.replaceTag(lastTagElm, tagData);else this.appendTag(tagElm); // if( _s.enforceWhitelist )\n      //     this.setContentEditable(false);\n\n      this.value[0] = tagData;\n      this.update();\n      this.trigger('add', {\n        tag: tagElm,\n        data: tagData\n      });\n      return [tagElm];\n    },\n\n    /**\r\n     * add an empty \"tag\" element in an editable state\r\n     */\n    addEmptyTag(initialData) {\n      var tagData = extend({\n        value: \"\"\n      }, initialData || {}),\n          tagElm = this.createTagElem(tagData);\n      getSetTagData(tagElm, tagData); // add the tag to the component's DOM\n\n      this.appendTag(tagElm);\n      this.editTag(tagElm, {\n        skipValidation: true\n      });\n    },\n\n    /**\r\n     * add a \"tag\" element to the \"tags\" component\r\n     * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\r\n     * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]\r\n     * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]\r\n     * @return {Array} Array of DOM elements (tags)\r\n     */\n    addTags(tagsItems, clearInput, skipInvalid) {\n      var tagElems = [],\n          _s = this.settings,\n          aggregatedinvalidInput = [],\n          frag = document.createDocumentFragment();\n      skipInvalid = skipInvalid || _s.skipInvalid;\n\n      if (!tagsItems || tagsItems.length == 0) {\n        return tagElems;\n      } // converts Array/String/Object to an Array of Objects\n\n\n      tagsItems = this.normalizeTags(tagsItems);\n\n      switch (_s.mode) {\n        case 'mix':\n          return this.addMixTags(tagsItems);\n\n        case 'select':\n          {\n            clearInput = false;\n            this.removeAllTags();\n          }\n      }\n\n      this.DOM.input.removeAttribute('style');\n      tagsItems.forEach(tagData => {\n        var tagElm,\n            tagElmParams = {},\n            originalData = Object.assign({}, tagData, {\n          value: tagData.value + \"\"\n        }); // shallow-clone tagData so later modifications will not apply to the source\n\n        tagData = Object.assign({}, originalData);\n\n        _s.transformTag.call(this, tagData);\n\n        tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData);\n\n        if (tagData.__isValid !== true) {\n          if (skipInvalid) return; // originalData is kept because it might be that this tag is invalid because it is a duplicate of another,\n          // and if that other tags is edited/deleted, this one should be re-validated and if is no more a duplicate - restored\n\n          extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {\n            __preInvalidData: originalData\n          });\n          if (tagData.__isValid == this.TEXTS.duplicate) // mark, for a brief moment, the tag (this this one) which THIS CURRENT tag is a duplcate of\n            this.flashTag(this.getTagElmByValue(tagData.value));\n\n          if (!_s.createInvalidTags) {\n            aggregatedinvalidInput.push(tagData.value);\n            return;\n          }\n        }\n\n        if ('readonly' in tagData) {\n          if (tagData.readonly) tagElmParams[\"aria-readonly\"] = true; // if \"readonly\" is \"false\", remove it from the tagData so it won't be added as an attribute in the template\n          else delete tagData.readonly;\n        } // Create tag HTML element\n\n\n        tagElm = this.createTagElem(tagData, tagElmParams);\n        tagElems.push(tagElm); // mode-select overrides\n\n        if (_s.mode == 'select') {\n          return this.selectTag(tagElm, tagData);\n        } // add the tag to the component's DOM\n        // this.appendTag(tagElm)\n\n\n        frag.appendChild(tagElm);\n\n        if (tagData.__isValid && tagData.__isValid === true) {\n          // update state\n          this.value.push(tagData);\n          this.trigger('add', {\n            tag: tagElm,\n            index: this.value.length - 1,\n            data: tagData\n          });\n        } else {\n          this.trigger(\"invalid\", {\n            data: tagData,\n            index: this.value.length,\n            tag: tagElm,\n            message: tagData.__isValid\n          });\n          if (!_s.keepInvalidTags) // remove invalid tags (if \"keepInvalidTags\" is set to \"false\")\n            setTimeout(() => this.removeTags(tagElm, true), 1000);\n        }\n\n        this.dropdown.position(); // reposition the dropdown because the just-added tag might cause a new-line\n      });\n      this.appendTag(frag);\n      this.update();\n\n      if (tagsItems.length && clearInput) {\n        this.input.set.call(this, _s.createInvalidTags ? '' : aggregatedinvalidInput.join(_s._delimiters));\n        this.setRangeAtStartEnd(false, this.DOM.input);\n      }\n\n      _s.dropdown.enabled && this.dropdown.refilter();\n      return tagElems;\n    },\n\n    /**\r\n     * Adds a mix-content tag\r\n     * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings\r\n     */\n    addMixTags(tagsData) {\n      tagsData = this.normalizeTags(tagsData);\n\n      if (tagsData[0].prefix || this.state.tag) {\n        return this.prefixedTextToTag(tagsData[0]);\n      }\n\n      if (typeof tagsData == 'string') tagsData = [{\n        value: tagsData\n      }];\n      var frag = document.createDocumentFragment();\n      tagsData.forEach(tagData => {\n        var tagElm = this.createTagElem(tagData);\n        frag.appendChild(tagElm);\n        this.insertAfterTag(tagElm);\n      });\n      this.appendMixTags(frag);\n      return frag;\n    },\n\n    appendMixTags(node) {\n      var selection = !!this.state.selection; // if \"selection\" exists, assumes intention of inecting the new tag at the last\n      // saved location of the caret inside \"this.DOM.input\"\n\n      if (selection) {\n        this.injectAtCaret(node);\n      } // else, create a range and inject the new tag as the last child of \"this.DOM.input\"\n      else {\n          this.DOM.input.focus();\n          selection = this.setStateSelection();\n          selection.range.setStart(this.DOM.input, selection.range.endOffset);\n          selection.range.setEnd(this.DOM.input, selection.range.endOffset);\n          this.DOM.input.appendChild(node);\n          this.updateValueByDOMTags(); // updates internal \"this.value\"\n\n          this.update(); // updates original input/textarea\n        }\n    },\n\n    /**\r\n     * Adds a tag which was activly typed by the user\r\n     * @param {String/Array} tagItem   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\r\n     */\n    prefixedTextToTag(tagItem) {\n      var _s = this.settings,\n          tagElm,\n          createdFromDelimiters = this.state.tag.delimiters;\n\n      _s.transformTag.call(this, tagItem);\n\n      tagItem.prefix = tagItem.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source || _s.pattern)[0]; // TODO: should check if the tag is valid\n\n      tagElm = this.createTagElem(tagItem); // tries to replace a taged textNode with a tagElm, and if not able,\n      // insert the new tag to the END if \"addTags\" was called from outside\n\n      if (!this.replaceTextWithNode(tagElm)) {\n        this.DOM.input.appendChild(tagElm);\n      }\n\n      setTimeout(() => tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300);\n      this.value.push(tagItem);\n      this.update();\n\n      if (!createdFromDelimiters) {\n        var elm = this.insertAfterTag(tagElm) || tagElm;\n        this.placeCaretAfterNode(elm);\n      }\n\n      this.state.tag = null;\n      this.trigger('add', extend({}, {\n        tag: tagElm\n      }, {\n        data: tagItem\n      }));\n      return tagElm;\n    },\n\n    /**\r\n     * appened (validated) tag to the component's DOM scope\r\n     */\n    appendTag(tagElm) {\n      var DOM = this.DOM,\n          insertBeforeNode = DOM.input; //if( insertBeforeNode === DOM.input )\n\n      DOM.scope.insertBefore(tagElm, insertBeforeNode); //else\n      //    DOM.scope.appendChild(tagElm)\n    },\n\n    /**\r\n     * creates a DOM tag element and injects it into the component (this.DOM.scope)\r\n     * @param  {Object}  tagData [text value & properties for the created tag]\r\n     * @param  {Object}  extraData [properties which are for the HTML template only]\r\n     * @return {Object} [DOM element]\r\n     */\n    createTagElem(tagData, extraData) {\n      tagData.__tagId = getUID();\n      var tagElm,\n          templateData = extend({}, tagData, _objectSpread2({\n        value: escapeHTML(tagData.value + \"\")\n      }, extraData)); // if( this.settings.readonly )\n      //     tagData.readonly = true\n\n      tagElm = this.parseTemplate('tag', [templateData, this]); // crucial for proper caret placement when deleting content. if textNodes are allowed as children of a tag element,\n      // a browser bug casues the caret to be misplaced inside the tag element (especcially affects \"readonly\" tags)\n\n      removeTextChildNodes(tagElm); // while( tagElm.lastChild.nodeType == 3 )\n      //     tagElm.lastChild.parentNode.removeChild(tagElm.lastChild)\n\n      getSetTagData(tagElm, tagData);\n      return tagElm;\n    },\n\n    /**\r\n     * re-check all invalid tags.\r\n     * called after a tag was edited or removed\r\n     */\n    reCheckInvalidTags() {\n      var _s = this.settings;\n      this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {\n        var tagData = getSetTagData(tagElm),\n            hasMaxTags = this.hasMaxTags(),\n            tagValidation = this.validateTag(tagData),\n            isValid = tagValidation === true && !hasMaxTags;\n        if (_s.mode == 'select') this.toggleScopeValidation(tagValidation); // if the tag has become valid\n\n        if (isValid) {\n          tagData = tagData.__preInvalidData ? tagData.__preInvalidData : {\n            value: tagData.value\n          };\n          return this.replaceTag(tagElm, tagData);\n        } // if the tag is still invaild, set its title as such (reson of invalid might have changed)\n\n\n        tagElm.title = hasMaxTags || tagValidation;\n      });\n    },\n\n    /**\r\n     * Removes a tag\r\n     * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]\r\n     * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]\r\n     * @param  {Number}             tranDuration    [Transition duration in MS]\r\n     * TODO: Allow multiple tags to be removed at-once\r\n     */\n    removeTags(tagElms, silent, tranDuration) {\n      var tagsToRemove,\n          _s = this.settings;\n      tagElms = tagElms && tagElms instanceof HTMLElement ? [tagElms] : tagElms instanceof Array ? tagElms : tagElms ? [tagElms] : [this.getLastTag()]; // normalize tagElms array values:\n      // 1. removing invalid items\n      // 2, if an item is String try to get the matching Tag HTML node\n      // 3. get the tag data\n      // 4. return a collection of Objects\n\n      tagsToRemove = tagElms.reduce((elms, tagElm) => {\n        if (tagElm && typeof tagElm == 'string') tagElm = this.getTagElmByValue(tagElm);\n        var tagData = getSetTagData(tagElm);\n        if (tagElm && tagData && !tagData.readonly) // make sure it's a tag and not some other node\n          // because the DOM node might be removed by async animation, the state will be updated while\n          // the node might still be in the DOM, so the \"update\" method should know which nodes to ignore\n          elms.push({\n            node: tagElm,\n            idx: this.getTagIdx(tagData),\n            // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)\n            data: getSetTagData(tagElm, {\n              '__removed': true\n            })\n          });\n        return elms;\n      }, []);\n      tranDuration = typeof tranDuration == \"number\" ? tranDuration : this.CSSVars.tagHideTransition;\n\n      if (_s.mode == 'select') {\n        tranDuration = 0;\n        this.input.set.call(this);\n      } // if only a single tag is to be removed.\n      // skip \"select\" mode because invalid tags are actually set to `this.value`\n\n\n      if (tagsToRemove.length == 1 && _s.mode != 'select') {\n        if (tagsToRemove[0].node.classList.contains(_s.classNames.tagNotAllowed)) silent = true;\n      }\n\n      if (!tagsToRemove.length) return;\n      return _s.hooks.beforeRemoveTag(tagsToRemove, {\n        tagify: this\n      }).then(() => {\n        function removeNode(tag) {\n          if (!tag.node.parentNode) return;\n          tag.node.parentNode.removeChild(tag.node);\n\n          if (!silent) {\n            // this.removeValueById(tagData.__uid)\n            this.trigger('remove', {\n              tag: tag.node,\n              index: tag.idx,\n              data: tag.data\n            });\n            this.dropdown.refilter();\n            this.dropdown.position();\n            this.DOM.input.normalize(); // best-practice when in mix-mode (safe to do always anyways)\n            // check if any of the current tags which might have been marked as \"duplicate\" should be un-marked\n\n            if (_s.keepInvalidTags) this.reCheckInvalidTags(); // below code is unfinished. it should iterate all currently invalid edited tags, which their edits have not\n            // changed the value yet, and should re-trigger the check, but since nothing has changed, it does not work...\n            // this.getTagElms(_s.classNames.tagEditing).forEach( this.events.callbacks.onEditTagBlur.bind )\n          } else if (_s.keepInvalidTags) this.trigger('remove', {\n            tag: tag.node,\n            index: tag.idx\n          });\n        }\n\n        function animation(tag) {\n          tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + 'px';\n          document.body.clientTop; // force repaint for the width to take affect before the \"hide\" class below\n\n          tag.node.classList.add(_s.classNames.tagHide); // manual timeout (hack, since transitionend cannot be used because of hover)\n\n          setTimeout(removeNode.bind(this), tranDuration, tag);\n        }\n\n        if (tranDuration && tranDuration > 10 && tagsToRemove.length == 1) animation.call(this, tagsToRemove[0]);else tagsToRemove.forEach(removeNode.bind(this)); // update state regardless of animation\n\n        if (!silent) {\n          this.removeTagsFromValue(tagsToRemove.map(tag => tag.node));\n          this.update(); // update the original input with the current value\n\n          if (_s.mode == 'select') this.setContentEditable(true);\n        }\n      }).catch(reason => {});\n    },\n\n    removeTagsFromDOM() {\n      [].slice.call(this.getTagElms()).forEach(elm => elm.parentNode.removeChild(elm));\n    },\n\n    /**\r\n     * @param {Array/Node} tags to be removed from the this.value array\r\n     */\n    removeTagsFromValue(tags) {\n      tags = Array.isArray(tags) ? tags : [tags];\n      tags.forEach(tag => {\n        var tagData = getSetTagData(tag),\n            tagIdx = this.getTagIdx(tagData); //  delete tagData.__removed\n\n        if (tagIdx > -1) this.value.splice(tagIdx, 1);\n      });\n    },\n\n    removeAllTags(opts) {\n      opts = opts || {};\n      this.value = [];\n      if (this.settings.mode == 'mix') this.DOM.input.innerHTML = '';else this.removeTagsFromDOM();\n      this.dropdown.refilter();\n      this.dropdown.position();\n      if (this.state.dropdown.visible) setTimeout(() => {\n        this.DOM.input.focus();\n      });\n\n      if (this.settings.mode == 'select') {\n        this.input.set.call(this);\n        this.setContentEditable(true);\n      } // technically for now only \"withoutChangeEvent\" exists in the opts.\n      // if more properties will be added later, only pass what's needed to \"update\"\n\n\n      this.update(opts);\n    },\n\n    postUpdate() {\n      var _s = this.settings,\n          classNames = _s.classNames,\n          hasValue = _s.mode == 'mix' ? _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;\n      this.toggleClass(classNames.hasMaxTags, this.value.length >= _s.maxTags);\n      this.toggleClass(classNames.hasNoTags, !this.value.length);\n      this.toggleClass(classNames.empty, !hasValue); // specifically the \"select mode\" might have the \"invalid\" classname set when the field is changed, so it must be toggled on add/remove/edit\n\n      if (_s.mode == 'select') {\n        var _this$value2, _this$value2$;\n\n        this.toggleScopeValidation((_this$value2 = this.value) === null || _this$value2 === void 0 ? void 0 : (_this$value2$ = _this$value2[0]) === null || _this$value2$ === void 0 ? void 0 : _this$value2$.__isValid);\n      }\n    },\n\n    setOriginalInputValue(v) {\n      var inputElm = this.DOM.originalInput;\n\n      if (!this.settings.mixMode.integrated) {\n        inputElm.value = v;\n        inputElm.tagifyValue = inputElm.value; // must set to \"inputElm.value\" and not again to \"inputValue\" because for some reason the browser changes the string afterwards a bit.\n\n        this.setPersistedData(v, 'value');\n      }\n    },\n\n    /**\r\n     * update the origianl (hidden) input field's value\r\n     * see - https://stackoverflow.com/q/50957841/104380\r\n     */\n    update(args) {\n      const UPDATE_DELAY = 100;\n      clearTimeout(this.debouncedUpdateTimeout);\n      this.debouncedUpdateTimeout = setTimeout(reallyUpdate.bind(this), UPDATE_DELAY);\n\n      function reallyUpdate() {\n        var inputValue = this.getInputValue();\n        this.setOriginalInputValue(inputValue);\n        this.postUpdate();\n        if ((!this.settings.onChangeAfterBlur || !(args || {}).withoutChangeEvent) && !this.state.blockChangeEvent) this.triggerChangeEvent();\n      }\n    },\n\n    getInputValue() {\n      var value = this.getCleanValue();\n      return this.settings.mode == 'mix' ? this.getMixedTagsAsString(value) : value.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(value) : JSON.stringify(value) : \"\";\n    },\n\n    /**\r\n     * removes properties from `this.value` which are only used internally\r\n     */\n    getCleanValue(v) {\n      return removeCollectionProp(v || this.value, this.dataProps);\n    },\n\n    getMixedTagsAsString() {\n      var result = \"\",\n          that = this,\n          _s = this.settings,\n          originalInputValueFormat = _s.originalInputValueFormat || JSON.stringify,\n          _interpolator = _s.mixTagsInterpolator;\n\n      function iterateChildren(rootNode) {\n        rootNode.childNodes.forEach(node => {\n          if (node.nodeType == 1) {\n            const tagData = getSetTagData(node);\n\n            if (node.tagName == 'BR') {\n              result += \"\\r\\n\";\n            }\n\n            if (tagData && isNodeTag.call(that, node)) {\n              if (tagData.__removed) return;else result += _interpolator[0] + originalInputValueFormat(omit(tagData, that.dataProps)) + _interpolator[1];\n            } else if (node.getAttribute('style') || ['B', 'I', 'U'].includes(node.tagName)) result += node.textContent;else if (node.tagName == 'DIV' || node.tagName == 'P') {\n              result += \"\\r\\n\"; //  if( !node.children.length && node.textContent )\n              //  result += node.textContent;\n\n              iterateChildren(node);\n            }\n          } else result += node.textContent;\n        });\n      }\n\n      iterateChildren(this.DOM.input);\n      return result;\n    }\n\n  }; // legacy support for changed methods names\n\n  Tagify.prototype.removeTag = Tagify.prototype.removeTags;\n  return Tagify;\n});","map":{"version":3,"sources":["C:/Users/HP/source/repos/MuhammadUsmaann/Knowledge-Base-Articles/KBProjectUI/node_modules/@yaireo/tagify/dist/tagify.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","Tagify","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","_toPropertyKey","configurable","writable","_toPrimitive","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","String","Number","arg","sameStr","s1","s2","caseSensitive","trim","toLowerCase","removeCollectionProp","collection","unwantedProps","Array","isArray","map","v","omit","props","newObj","p","indexOf","decode","s","el","document","createElement","replace","enc","innerHTML","innerText","parseHTML","parser","DOMParser","node","parseFromString","body","firstElementChild","minify","m","$1","removeTextChildNodes","elm","iter","createNodeIterator","NodeFilter","SHOW_TEXT","textnode","nextNode","textContent","parentNode","removeChild","getfirstTextNode","action","nodeType","escapeHTML","isObject","type","prototype","toString","split","slice","extend","o","o1","o2","copy","a","b","hasOwnProperty","assign","concatWithoutDups","newArr","existingObj","arr","item","includes","unaccent","normalize","getNodeHeight","height","clone","cloneNode","style","cssText","appendChild","clientHeight","isChromeAndroidBrowser","test","navigator","userAgent","getUID","c","crypto","getRandomValues","Uint8Array","isNodeTag","classList","contains","settings","classNames","tag","getCaretGlobalPosition","sel","getSelection","rangeCount","r","getRangeAt","startContainer","offset","startOffset","rect","r2","createRange","setStart","setEnd","getBoundingClientRect","left","right","top","bottom","injectAtCaret","content","range","selection","window","createTextNode","deleteContents","insertNode","getSetTagData","tagElm","data","override","console","warn","__tagifyTagData","DEFAULTS","delimiters","pattern","tagTextProp","maxTags","Infinity","callbacks","addTagOnBlur","onChangeAfterBlur","duplicates","whitelist","blacklist","enforceWhitelist","userInput","keepInvalidTags","createInvalidTags","mixTagsAllowedAfter","mixTagsInterpolator","backspace","skipInvalid","pasteAsTags","editTags","clicks","keepInvalid","transformTag","a11y","focusableTags","mixMode","insertAfterTag","autoComplete","enabled","rightKey","namespace","selectMode","focus","tagNoAnimation","tagInvalid","tagNotAllowed","scopeLoading","hasMaxTags","hasNoTags","empty","inputInvalid","dropdown","dropdownWrapper","dropdownHeader","dropdownFooter","dropdownItem","dropdownItemActive","dropdownItemHidden","dropdownInital","tagText","tagX","tagLoading","tagEditing","tagFlash","tagHide","classname","maxItems","searchKeys","fuzzySearch","accentedSearch","includeSelectedTags","highlightFirst","closeOnSelect","clearOnSelect","position","appendTarget","hooks","beforeRemoveTag","Promise","resolve","beforePaste","suggestionClick","initDropdown","_dropdown","bind","refs","DOM","parseTemplate","querySelector","getHeaderRef","getFooterRef","getAllSuggestionsRefs","querySelectorAll","dropdownItemSelector","show","_s","firstListItem","firstListItemValue","allowNewTags","mode","noWhitelist","noMatchListItem","isManual","state","inputText","templates","dropdownItemNoMatch","enable","isLoading","readonly","clearTimeout","dropdownHide__bindEventsTimeout","suggestedListItems","filterListItems","trigger","editing","scope","unshift","autocomplete","suggest","hide","fill","highlightOption","visible","setTimeout","events","binding","query","setStateSelection","render","overrideManual","_this$DOM","removeEventListener","setAttribute","ddItemData","ddItemElm","flaggedTags","baseOffset","toggle","ddHeight","add","remove","HTMLContent","createListHTML","dropdownContent","fillHeaderFooter","suggestions","newHeaderElem","newFooterElem","headerRef","footerRef","replaceChild","refilter","_sd","width","parentsPositions","ddElm","placeAbove","isDefaultAppendTarget","appendTargetScrollTop","pageYOffset","scrollTop","root","fullscreenElement","webkitFullscreenElement","documentElement","viewportHeight","viewportWidth","Math","max","clientWidth","innerWidth","positionTo","ddTarget","getParentsPositions","offsetLeft","offsetTop","getAccumulatedAncestorsScrollTop","accumulatedAncestorsScrollTop","floor","ceil","pageXOffset","bindUnbind","_CB","_CBR","listeners","onKeyDown","onMouseOver","onMouseLeave","onClick","onScroll","e","hasFocus","composing","selectedElm","dropdownItemActiveSelector","selectedElmData","getSuggestionDataByNode","preventDefault","dropdownItems","actionUp","getNextOrPrevOption","matches","actions","ArrowLeft","getMappedValue","set","tagify","tagData","suggestionElm","then","selectOption","addTags","catch","err","raw","charCodeAt","removeTags","editTag","ddItem","closest","button","pos","scrollHeight","percentage","round","getAttribute","find","selected","next","selectedIdx","findIndex","adjustScroll","className","itemData","removeAttribute","event","_this$settings$dropdo","isNoMatch","onEditTagDone","__isValid","normalizeTags","toggleFocusClass","setRangeAtStartEnd","addEventListener","once","selectAll","onlyRendered","tagsToAdd","options","list","exactMatchesList","suggestionsCount","whitelistItem","valueIsInWhitelist","searchBy","isDuplicate","niddle","isTagDuplicate","stringHasAll","every","q","startsWithMatch","exactMatch","itemWithoutSearchKeys","some","k","_searchKeys","exact","reduce","values","sortby","concat","mapValueTo","sugegstionsList","suggestion","idx","mappedValue","join","VERSION","STORE_KEY","getPersistedData","id","customKey","persistedData","versionMatch","localStorage","getItem","JSON","parse","setPersistedData","setItem","stringify","dispatchEvent","Event","clearPersistedData","base","removeItem","TEXTS","exceed","duplicate","notAllowed","wrapper","disabled","required","placeholder","_ref","title","class","getAttributes","hasMore","EventDispatcher","instance","addRemove","op","cb","name","off","on","eventName","opts","cloneData","isJQueryPlugin","jQuery","originalInput","triggerHandler","eventData","cloneEvent","prop","HTMLElement","CustomEvent","deleteBackspaceTimeout","triggerChangeEvent","integrated","inputElm","changed","lastOriginalValueReported","bubbles","simulated","_valueTracker","setValue","random","customBinding","customEventsList","mainEvents","main","bindGlobal","removeAllTags","onFocusBlur","keydown","onKeydown","click","onClickScope","dblclick","onDoubleClickScope","paste","onPaste","drop","onDrop","compositionstart","onCompositionStart","compositionend","onCompositionEnd","clearInterval","originalInputValueObserverInterval","setInterval","observeOriginalInputValue","inputMutationObserver","MutationObserver","onInputDOMChange","disconnect","observe","childList","unbind","isIE","onWindowKeyDown","unbindGlobal","text","currentDisplayValue","ddEnabled","relatedTarget","isTargetSelectOption","isTargetAddNewBtn","addNew","isRelatedTargetX","shouldAddTags","postUpdate","Date","loading","focusedElm","activeElement","isTag","isBelong","nextTag","nextElementSibling","deleteKeyTagDetected","anchorOffset","anchorNode","prevAnchorSibling","previousSibling","isCaretAfterTag","lastTagElems","getTagElms","tagBeforeCaret","tagElmToBeDeleted","firstTextNodeBeforeTag","previousElementSibling","Element","hasAttribute","placeCaretAfterNode","nodeName","min","nodeValue","nodeIdx","index","n","blur","inputSuggestion","onInput","onMixTagsInput","showSuggestions","validation","validateTag","toggleScopeValidation","isValid","search","rangeText","match","matchedPatternCount","lastTagsCount","matchFlaggedTag","matchDelimiters","tagsElems","fragment","createDocumentFragment","remainingTagsValues","inputType","createTagElem","childNodes","lastChild","update","withoutChangeEvent","cloneRange","collapse","focusNode","endOffset","lastIndexOf","prefix","onInputIE","_this","destroy","tagifyValue","loadOriginalValues","timeDiffFocus","getNodeIndex","fixFirefoxLastTagNoCaret","selectModeWithoutInput","clipboardData","pastedText","getData","result","onEditTagInput","editableElm","tagElmIdx","textValue","dataForChangedProp","__tagId","hasChanged","editTagChangeDetected","originalIsValid","newValue","onEditTagPaste","newNode","onEditTagFocus","onEditTagBlur","originalData","__originalData","newTagData","message","onEditTagkeydown","__originalHTML","isEditingTag","isReadyOnlyTag","editable","record","addedNodes","addedNode","outerHTML","replaceWith","tagSelector","newlineText","nextSibling","anythingAfterNode","removedNodes","removedNode","lastInputChild","mockInstance","Proxy","get","__tagify","isFirefox","documentMode","applySettings","build","getCSSVars","autofocus","helpers","dataProps","template","generateClassSelectors","currentName","mixModeDefaults","mergedDefaults","attrVal","RegExp","_delimiters","texts","persistedWhitelist","attrs","getCustomAttributes","output","propName","compStyle","getComputedStyle","getProp","getPropertyValue","seprateUnitFromValue","unit","pop","CSSVars","tagHideTransition","originalInput_tabIndex","tabIndex","inputSelector","insertBefore","blockChangeEvent","persistedOriginalValue","parseMixTags","tagName","insertAdjacentHTML","clonedEvent","toggleClass","force","start","setStartAfter","removeAllRanges","addRange","getTagTextNode","tagTextSelector","setTagTextNode","HTML","getLastTag","tagIdx","that","delayed_onEditTagBlur","skipValidation","editTagToggleValidity","removeTagsFromValue","previousData","replaceTag","reCheckInvalidTags","getInvalidTagAttrs","newTagElm","updateValueByDOMTags","injectedNode","appendMixTags","updateDOM","hideDropdown","validate","charAt","suggestedText","suggestionStart","substr","suggestionTrimmed","substring","dataSuggest","replaceTextWithNode","getTagIdx","_len","classess","_key","lastTag","tagId","dupsCount","isSameStr","getTagIndexByValue","indices","getTagElmByValue","flashTag","isTagBlacklisted","x","isTagWhitelisted","getWhitelistItem","_wi","_wiv","setReadonly","attrribute","setContentEditable","contentEditable","setDisabled","isDisabled","tagsItems","_this$settings","whitelistMatches","whitelistWithProps","isCollection","mapStringToCollection","whitelistMatchesValues","filteredList","filteredItem","matchObj","_this$settings2","tagsDataSet","preInterpolated","maxTagsReached","textProp","Error","newWrapperNode","strToReplace","nodeToReplace","nodeAtCaret","firstSplitOffset","splitText","selectTag","lastTagElm","appendTag","addEmptyTag","initialData","clearInput","tagElems","aggregatedinvalidInput","frag","addMixTags","tagElmParams","__preInvalidData","tagsData","prefixedTextToTag","tagItem","createdFromDelimiters","insertBeforeNode","extraData","templateData","tagValidation","tagElms","silent","tranDuration","tagsToRemove","elms","removeNode","animation","parseFloat","clientTop","reason","removeTagsFromDOM","tags","splice","hasValue","setOriginalInputValue","args","UPDATE_DELAY","debouncedUpdateTimeout","reallyUpdate","inputValue","getInputValue","getCleanValue","getMixedTagsAsString","originalInputValueFormat","_interpolator","iterateChildren","rootNode","__removed","removeTag"],"mappings":"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","sourcesContent":["/**\n * Tagify (v 4.17.6) - tags input component\n * By undefined\n * https://github.com/yairEO/tagify\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n * \r\n * THE SOFTWARE IS NOT PERMISSIBLE TO BE SOLD.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Tagify = factory());\n})(this, (function () { 'use strict';\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n    return target;\n  }\n  function _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n\n  // console.json = console.json || function(argument){\n  //     for(var arg=0; arg < arguments.length; ++arg)\n  //         console.log(  JSON.stringify(arguments[arg], null, 4)  )\n  // }\n\n  // const isEdge = /Edge/.test(navigator.userAgent)\n  const sameStr = (s1, s2, caseSensitive, trim) => {\n    // cast to String\n    s1 = \"\" + s1;\n    s2 = \"\" + s2;\n    if (trim) {\n      s1 = s1.trim();\n      s2 = s2.trim();\n    }\n    return caseSensitive ? s1 == s2 : s1.toLowerCase() == s2.toLowerCase();\n  };\n\n  // const getUID = () => (new Date().getTime() + Math.floor((Math.random()*10000)+1)).toString(16)\n  const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map(v => omit(v, unwantedProps));\n  function omit(obj, props) {\n    var newObj = {},\n      p;\n    for (p in obj) if (props.indexOf(p) < 0) newObj[p] = obj[p];\n    return newObj;\n  }\n  function decode(s) {\n    var el = document.createElement('div');\n    return s.replace(/\\&#?[0-9a-z]+;/gi, function (enc) {\n      el.innerHTML = enc;\n      return el.innerText;\n    });\n  }\n\n  /**\r\n   * utility method\r\n   * https://stackoverflow.com/a/35385518/104380\r\n   * @param  {String} s [HTML string]\r\n   * @return {Object}   [DOM node]\r\n   */\n  function parseHTML(s) {\n    var parser = new DOMParser(),\n      node = parser.parseFromString(s.trim(), \"text/html\");\n    return node.body.firstElementChild;\n  }\n\n  /**\r\n   * Removed new lines and irrelevant spaces which might affect layout, and are better gone\r\n   * @param {string} s [HTML string]\r\n   */\n  function minify(s) {\n    return s ? s.replace(/\\>[\\r\\n ]+\\</g, \"><\").replace(/(<.*?>)|\\s+/g, (m, $1) => $1 ? $1 : ' ') // https://stackoverflow.com/a/44841484/104380\n    : \"\";\n  }\n  function removeTextChildNodes(elm) {\n    var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false),\n      textnode;\n\n    // print all text nodes\n    while (textnode = iter.nextNode()) {\n      if (!textnode.textContent.trim()) textnode.parentNode.removeChild(textnode);\n    }\n  }\n  function getfirstTextNode(elm, action) {\n    action = action || 'previous';\n    while (elm = elm[action + 'Sibling']) if (elm.nodeType == 3) return elm;\n  }\n\n  /**\r\n   * utility method\r\n   * https://stackoverflow.com/a/6234804/104380\r\n   */\n  function escapeHTML(s) {\n    return typeof s == 'string' ? s.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/`|'/g, \"&#039;\") : s;\n  }\n\n  /**\r\n   * Checks if an argument is a javascript Object\r\n   */\n  function isObject(obj) {\n    var type = Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);\n    return obj === Object(obj) && type != 'Array' && type != 'Function' && type != 'RegExp' && type != 'HTMLUnknownElement';\n  }\n\n  /**\r\n   * merge objects into a single new one\r\n   * TEST: extend({}, {a:{foo:1}, b:[]}, {a:{bar:2}, b:[1], c:()=>{}})\r\n   */\n  function extend(o, o1, o2) {\n    if (!(o instanceof Object)) o = {};\n    copy(o, o1);\n    if (o2) copy(o, o2);\n    function copy(a, b) {\n      // copy o2 to o\n      for (var key in b) if (b.hasOwnProperty(key)) {\n        if (isObject(b[key])) {\n          if (!isObject(a[key])) a[key] = Object.assign({}, b[key]);else copy(a[key], b[key]);\n          continue;\n        }\n        if (Array.isArray(b[key])) {\n          a[key] = Object.assign([], b[key]);\n          continue;\n        }\n        a[key] = b[key];\n      }\n    }\n    return o;\n  }\n\n  /**\r\n   * concatenates N arrays without dups.\r\n   * If an array's item is an Object, compare by `value`\r\n   */\n  function concatWithoutDups() {\n    const newArr = [],\n      existingObj = {};\n    for (let arr of arguments) {\n      for (let item of arr) {\n        // if current item is an object which has yet to be added to the new array\n        if (isObject(item)) {\n          if (!existingObj[item.value]) {\n            newArr.push(item);\n            existingObj[item.value] = 1;\n          }\n        }\n\n        // if current item is not an object and is not in the new array\n        else if (!newArr.includes(item)) newArr.push(item);\n      }\n    }\n    return newArr;\n  }\n\n  /**\r\n   *  Extracted from: https://stackoverflow.com/a/37511463/104380\r\n   * @param {String} s\r\n   */\n  function unaccent(s) {\n    // if not supported, do not continue.\n    // developers should use a polyfill:\n    // https://github.com/walling/unorm\n    if (!String.prototype.normalize) return s;\n    if (typeof s === 'string') return s.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n  }\n\n  /**\r\n   * Meassures an element's height, which might yet have been added DOM\r\n   * https://stackoverflow.com/q/5944038/104380\r\n   * @param {DOM} node\r\n   */\n  function getNodeHeight(node) {\n    var height,\n      clone = node.cloneNode(true);\n    clone.style.cssText = \"position:fixed; top:-9999px; opacity:0\";\n    document.body.appendChild(clone);\n    height = clone.clientHeight;\n    clone.parentNode.removeChild(clone);\n    return height;\n  }\n  var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);\n  function getUID() {\n    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n  }\n  function isNodeTag(node) {\n    return node && node.classList && node.classList.contains(this.settings.classNames.tag);\n  }\n\n  /**\r\n  * Get the caret position relative to the viewport\r\n  * https://stackoverflow.com/q/58985076/104380\r\n  *\r\n  * @returns {object} left, top distance in pixels\r\n  */\n  function getCaretGlobalPosition() {\n    const sel = document.getSelection();\n    if (sel.rangeCount) {\n      const r = sel.getRangeAt(0);\n      const node = r.startContainer;\n      const offset = r.startOffset;\n      let rect, r2;\n      if (offset > 0) {\n        r2 = document.createRange();\n        r2.setStart(node, offset - 1);\n        r2.setEnd(node, offset);\n        rect = r2.getBoundingClientRect();\n        return {\n          left: rect.right,\n          top: rect.top,\n          bottom: rect.bottom\n        };\n      }\n      if (node.getBoundingClientRect) return node.getBoundingClientRect();\n    }\n    return {\n      left: -9999,\n      top: -9999\n    };\n  }\n\n  /**\r\n   * Injects content (either string or node) at the current the current (or specificed) caret position\r\n   * @param {content} string/node\r\n   * @param {range} Object (optional, a range other than the current window selection)\r\n   */\n  function injectAtCaret(content, range) {\n    var selection = window.getSelection();\n    range = range || selection.getRangeAt(0);\n    if (typeof content == 'string') content = document.createTextNode(content);\n    if (range) {\n      range.deleteContents();\n      range.insertNode(content);\n    }\n    return content;\n  }\n\n  /** Setter/Getter\r\n   * Each tag DOM node contains a custom property called \"__tagifyTagData\" which hosts its data\r\n   * @param {Node}   tagElm\r\n   * @param {Object} data\r\n   */\n  function getSetTagData(tagElm, data, override) {\n    if (!tagElm) {\n      console.warn(\"tag element doesn't exist\", tagElm, data);\n      return data;\n    }\n    if (data) tagElm.__tagifyTagData = override ? data : extend({}, tagElm.__tagifyTagData || {}, data);\n    return tagElm.__tagifyTagData;\n  }\n\n  var DEFAULTS = {\n    delimiters: \",\",\n    // [RegEx] split tags by any of these delimiters (\"null\" to cancel) Example: \",| |.\"\n    pattern: null,\n    // RegEx pattern to validate input by. Ex: /[1-9]/\n    tagTextProp: 'value',\n    // tag data Object property which will be displayed as the tag's text\n    maxTags: Infinity,\n    // Maximum number of tags\n    callbacks: {},\n    // Exposed callbacks object to be triggered on certain events\n    addTagOnBlur: true,\n    // automatically adds the text which was inputed as a tag when blur event happens\n    onChangeAfterBlur: true,\n    // By default, the native way of inputs' onChange events is kept, and it only fires when the field is blured.\n    duplicates: false,\n    // \"true\" - allow duplicate tags\n    whitelist: [],\n    // Array of tags to suggest as the user types (can be used along with \"enforceWhitelist\" setting)\n    blacklist: [],\n    // A list of non-allowed tags\n    enforceWhitelist: false,\n    // Only allow tags from the whitelist\n    userInput: true,\n    // disable manually typing/pasting/editing tags (tags may only be added from the whitelist)\n    keepInvalidTags: false,\n    // if true, do not remove tags which did not pass validation\n    createInvalidTags: true,\n    // if false, do not create invalid tags from invalid user input\n    mixTagsAllowedAfter: /,|\\.|\\:|\\s/,\n    // RegEx - Define conditions in which mix-tags content allows a tag to be added after\n    mixTagsInterpolator: ['[[', ']]'],\n    // Interpolation for mix mode. Everything between these will become a tag, if is a valid Object\n    backspace: true,\n    // false / true / \"edit\"\n    skipInvalid: false,\n    // If `true`, do not add invalid, temporary, tags before automatically removing them\n    pasteAsTags: true,\n    // automatically converts pasted text into tags. if \"false\", allows for further text editing\n\n    editTags: {\n      clicks: 2,\n      // clicks to enter \"edit-mode\": 1 for single click. any other value is considered as double-click\n      keepInvalid: true // keeps invalid edits as-is until `esc` is pressed while in focus\n    },\n\n    // 1 or 2 clicks to edit a tag. false/null for not allowing editing\n    transformTag: () => {},\n    // Takes a tag input string as argument and returns a transformed value\n    trim: true,\n    // whether or not the value provided should be trimmed, before being added as a tag\n    a11y: {\n      focusableTags: false\n    },\n    mixMode: {\n      insertAfterTag: '\\u00A0' // String/Node to inject after a tag has been added (see #588)\n    },\n\n    autoComplete: {\n      enabled: true,\n      // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text\n      rightKey: false // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to \"true\"\n    },\n\n    classNames: {\n      namespace: 'tagify',\n      mixMode: 'tagify--mix',\n      selectMode: 'tagify--select',\n      input: 'tagify__input',\n      focus: 'tagify--focus',\n      tagNoAnimation: 'tagify--noAnim',\n      tagInvalid: 'tagify--invalid',\n      tagNotAllowed: 'tagify--notAllowed',\n      scopeLoading: 'tagify--loading',\n      hasMaxTags: 'tagify--hasMaxTags',\n      hasNoTags: 'tagify--noTags',\n      empty: 'tagify--empty',\n      inputInvalid: 'tagify__input--invalid',\n      dropdown: 'tagify__dropdown',\n      dropdownWrapper: 'tagify__dropdown__wrapper',\n      dropdownHeader: 'tagify__dropdown__header',\n      dropdownFooter: 'tagify__dropdown__footer',\n      dropdownItem: 'tagify__dropdown__item',\n      dropdownItemActive: 'tagify__dropdown__item--active',\n      dropdownItemHidden: 'tagify__dropdown__item--hidden',\n      dropdownInital: 'tagify__dropdown--initial',\n      tag: 'tagify__tag',\n      tagText: 'tagify__tag-text',\n      tagX: 'tagify__tag__removeBtn',\n      tagLoading: 'tagify__tag--loading',\n      tagEditing: 'tagify__tag--editable',\n      tagFlash: 'tagify__tag--flash',\n      tagHide: 'tagify__tag--hide'\n    },\n    dropdown: {\n      classname: '',\n      enabled: 2,\n      // minimum input characters to be typed for the suggestions dropdown to show\n      maxItems: 10,\n      searchKeys: [\"value\", \"searchBy\"],\n      fuzzySearch: true,\n      caseSensitive: false,\n      accentedSearch: true,\n      includeSelectedTags: false,\n      // Should the suggestions list Include already-selected tags (after filtering)\n      highlightFirst: false,\n      // highlights first-matched item in the list\n      closeOnSelect: true,\n      // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)\n      clearOnSelect: true,\n      // after selecting a suggetion, should the typed text input remain or be cleared\n      position: 'all',\n      // 'manual' / 'text' / 'all'\n      appendTarget: null // defaults to document.body once DOM has been loaded\n    },\n\n    hooks: {\n      beforeRemoveTag: () => Promise.resolve(),\n      beforePaste: () => Promise.resolve(),\n      suggestionClick: () => Promise.resolve()\n    }\n  };\n\n  function initDropdown() {\n    this.dropdown = {};\n\n    // auto-bind \"this\" to all the dropdown methods\n    for (let p in this._dropdown) this.dropdown[p] = typeof this._dropdown[p] === 'function' ? this._dropdown[p].bind(this) : this._dropdown[p];\n    this.dropdown.refs();\n  }\n  var _dropdown = {\n    refs() {\n      this.DOM.dropdown = this.parseTemplate('dropdown', [this.settings]);\n      this.DOM.dropdown.content = this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-wrapper']\");\n    },\n    getHeaderRef() {\n      return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-header']\");\n    },\n    getFooterRef() {\n      return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-footer']\");\n    },\n    getAllSuggestionsRefs() {\n      return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)];\n    },\n    /**\r\n     * shows the suggestions select box\r\n     * @param {String} value [optional, filter the whitelist by this value]\r\n     */\n    show(value) {\n      var _s = this.settings,\n        firstListItem,\n        firstListItemValue,\n        allowNewTags = _s.mode == 'mix' && !_s.enforceWhitelist,\n        noWhitelist = !_s.whitelist || !_s.whitelist.length,\n        noMatchListItem,\n        isManual = _s.dropdown.position == 'manual';\n\n      // if text still exists in the input, and `show` method has no argument, then the input's text should be used\n      value = value === undefined ? this.state.inputText : value;\n\n      // ⚠️ Do not render suggestions list  if:\n      // 1. there's no whitelist (can happen while async loading) AND new tags arn't allowed\n      // 2. dropdown is disabled\n      // 3. loader is showing (controlled outside of this code)\n      if (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch || _s.dropdown.enable === false || this.state.isLoading || this.settings.readonly) return;\n      clearTimeout(this.dropdownHide__bindEventsTimeout);\n\n      // if no value was supplied, show all the \"whitelist\" items in the dropdown\n      // @type [Array] listItems\n      // TODO: add a Setting to control items' sort order for \"listItems\"\n      this.suggestedListItems = this.dropdown.filterListItems(value);\n\n      // trigger at this exact point to let the developer the chance to manually set \"this.suggestedListItems\"\n      if (value && !this.suggestedListItems.length) {\n        this.trigger('dropdown:noMatch', value);\n        if (_s.templates.dropdownItemNoMatch) noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {\n          value\n        });\n      }\n\n      // if \"dropdownItemNoMatch\" was no defined, procceed regular flow.\n      //\n      if (!noMatchListItem) {\n        // in mix-mode, if the value isn't included in the whilelist & \"enforceWhitelist\" setting is \"false\",\n        // then add a custom suggestion item to the dropdown\n        if (this.suggestedListItems.length) {\n          if (value && allowNewTags && !this.state.editing.scope && !sameStr(this.suggestedListItems[0].value, value)) this.suggestedListItems.unshift({\n            value\n          });\n        } else {\n          if (value && allowNewTags && !this.state.editing.scope) {\n            this.suggestedListItems = [{\n              value\n            }];\n          }\n          // hide suggestions list if no suggestion matched\n          else {\n            this.input.autocomplete.suggest.call(this);\n            this.dropdown.hide();\n            return;\n          }\n        }\n        firstListItem = this.suggestedListItems[0];\n        firstListItemValue = \"\" + (isObject(firstListItem) ? firstListItem.value : firstListItem);\n        if (_s.autoComplete && firstListItemValue) {\n          // only fill the sugegstion if the value of the first list item STARTS with the input value (regardless of \"fuzzysearch\" setting)\n          if (firstListItemValue.indexOf(value) == 0) this.input.autocomplete.suggest.call(this, firstListItem);\n        }\n      }\n      this.dropdown.fill(noMatchListItem);\n      if (_s.dropdown.highlightFirst) {\n        this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(_s.classNames.dropdownItemSelector));\n      }\n\n      // bind events, exactly at this stage of the code. \"dropdown.show\" method is allowed to be\n      // called multiple times, regardless if the dropdown is currently visible, but the events-binding\n      // should only be called if the dropdown wasn't previously visible.\n      if (!this.state.dropdown.visible)\n        // timeout is needed for when pressing arrow down to show the dropdown,\n        // so the key event won't get registered in the dropdown events listeners\n        setTimeout(this.dropdown.events.binding.bind(this));\n\n      // set the dropdown visible state to be the same as the searched value.\n      // MUST be set *before* position() is called\n      this.state.dropdown.visible = value || true;\n      this.state.dropdown.query = value;\n      this.setStateSelection();\n\n      // try to positioning the dropdown (it might not yet be on the page, doesn't matter, next code handles this)\n      if (!isManual) {\n        // a slight delay is needed if the dropdown \"position\" setting is \"text\", and nothing was typed in the input,\n        // so sadly the \"getCaretGlobalPosition\" method doesn't recognize the caret position without this delay\n        setTimeout(() => {\n          this.dropdown.position();\n          this.dropdown.render();\n        });\n      }\n\n      // a delay is needed because of the previous delay reason.\n      // this event must be fired after the dropdown was rendered & positioned\n      setTimeout(() => {\n        this.trigger(\"dropdown:show\", this.DOM.dropdown);\n      });\n    },\n    /**\r\n     * Hides the dropdown (if it's not managed manually by the developer)\r\n     * @param {Boolean} overrideManual\r\n     */\n    hide(overrideManual) {\n      var _this$DOM = this.DOM,\n        scope = _this$DOM.scope,\n        dropdown = _this$DOM.dropdown,\n        isManual = this.settings.dropdown.position == 'manual' && !overrideManual;\n\n      // if there's no dropdown, this means the dropdown events aren't binded\n      if (!dropdown || !document.body.contains(dropdown) || isManual) return;\n      window.removeEventListener('resize', this.dropdown.position);\n      this.dropdown.events.binding.call(this, false); // unbind all events\n\n      // if the dropdown is open, and the input (scope) is clicked,\n      // the dropdown should be now \"close\", and the next click (on the scope)\n      // should re-open it, and without a timeout, clicking to close will re-open immediately\n      //  clearTimeout(this.dropdownHide__bindEventsTimeout)\n      //  this.dropdownHide__bindEventsTimeout = setTimeout(this.events.binding.bind(this), 250)  // re-bind main events\n\n      scope.setAttribute(\"aria-expanded\", false);\n      dropdown.parentNode.removeChild(dropdown);\n\n      // scenario: clicking the scope to show the dropdown, clicking again to hide -> calls dropdown.hide() and then re-focuses the input\n      // which casues another onFocus event, which checked \"this.state.dropdown.visible\" and see it as \"false\" and re-open the dropdown\n      setTimeout(() => {\n        this.state.dropdown.visible = false;\n      }, 100);\n      this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null;\n\n      // if the user closed the dropdown (in mix-mode) while a potential tag was detected, flag the current tag\n      // so the dropdown won't be shown on following user input for that \"tag\"\n      if (this.state.tag && this.state.tag.value.length) {\n        this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag;\n      }\n      this.trigger(\"dropdown:hide\", dropdown);\n      return this;\n    },\n    /**\r\n     * Toggles dropdown show/hide\r\n     * @param {Boolean} show forces the dropdown to show\r\n     */\n    toggle(show) {\n      this.dropdown[this.state.dropdown.visible && !show ? 'hide' : 'show']();\n    },\n    render() {\n      // let the element render in the DOM first, to accurately measure it.\n      // this.DOM.dropdown.style.cssText = \"left:-9999px; top:-9999px;\";\n      var ddHeight = getNodeHeight(this.DOM.dropdown),\n        _s = this.settings,\n        enabled = typeof _s.dropdown.enabled == 'number' && _s.dropdown.enabled >= 0;\n      if (!enabled) return this;\n      this.DOM.scope.setAttribute(\"aria-expanded\", true);\n\n      // if the dropdown has yet to be appended to the DOM,\n      // append the dropdown to the body element & handle events\n      if (!document.body.contains(this.DOM.dropdown)) {\n        this.DOM.dropdown.classList.add(_s.classNames.dropdownInital);\n        this.dropdown.position(ddHeight);\n        _s.dropdown.appendTarget.appendChild(this.DOM.dropdown);\n        setTimeout(() => this.DOM.dropdown.classList.remove(_s.classNames.dropdownInital));\n      }\n      return this;\n    },\n    /**\r\n     * re-renders the dropdown content element (see \"dropdownContent\" in templates file)\r\n     * @param {String/Array} HTMLContent - optional\r\n     */\n    fill(HTMLContent) {\n      HTMLContent = typeof HTMLContent == 'string' ? HTMLContent : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems);\n      var dropdownContent = this.settings.templates.dropdownContent.call(this, HTMLContent);\n      this.DOM.dropdown.content.innerHTML = minify(dropdownContent);\n    },\n    /**\r\n     * Re-renders only the header & footer.\r\n     * Used when selecting a suggestion and it is wanted that the suggestions dropdown stays open.\r\n     * Since the list of sugegstions is not being re-rendered completely every time a suggestion is selected (the item is transitioned-out)\r\n     * then the header & footer should be kept in sync with the suggestions data change\r\n     */\n    fillHeaderFooter() {\n      var suggestions = this.dropdown.filterListItems(this.state.dropdown.query),\n        newHeaderElem = this.parseTemplate('dropdownHeader', [suggestions]),\n        newFooterElem = this.parseTemplate('dropdownFooter', [suggestions]),\n        headerRef = this.dropdown.getHeaderRef(),\n        footerRef = this.dropdown.getFooterRef();\n      newHeaderElem && headerRef?.parentNode.replaceChild(newHeaderElem, headerRef);\n      newFooterElem && footerRef?.parentNode.replaceChild(newFooterElem, footerRef);\n    },\n    /**\r\n     * fill data into the suggestions list\r\n     * (mainly used to update the list when removing tags while the suggestions dropdown is visible, so they will be re-added to the list. not efficient)\r\n     */\n    refilter(value) {\n      value = value || this.state.dropdown.query || '';\n      this.suggestedListItems = this.dropdown.filterListItems(value);\n      this.dropdown.fill();\n      if (!this.suggestedListItems.length) this.dropdown.hide();\n      this.trigger(\"dropdown:updated\", this.DOM.dropdown);\n    },\n    position(ddHeight) {\n      var _sd = this.settings.dropdown;\n      if (_sd.position == 'manual') return;\n      var rect,\n        top,\n        bottom,\n        left,\n        width,\n        parentsPositions,\n        ddElm = this.DOM.dropdown,\n        placeAbove = _sd.placeAbove,\n        isDefaultAppendTarget = _sd.appendTarget === document.body,\n        appendTargetScrollTop = isDefaultAppendTarget ? window.pageYOffset : _sd.appendTarget.scrollTop,\n        root = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement,\n        viewportHeight = root.clientHeight,\n        viewportWidth = Math.max(root.clientWidth || 0, window.innerWidth || 0),\n        positionTo = viewportWidth > 480 ? _sd.position : 'all',\n        ddTarget = this.DOM[positionTo == 'input' ? 'input' : 'scope'];\n      ddHeight = ddHeight || ddElm.clientHeight;\n      function getParentsPositions(p) {\n        var left = 0,\n          top = 0;\n\n        // when in element-fullscreen mode, do not go above the fullscreened-element\n        while (p && p != root) {\n          left += p.offsetLeft || 0;\n          top += p.offsetTop || 0;\n          p = p.parentNode;\n        }\n        return {\n          left,\n          top\n        };\n      }\n      function getAccumulatedAncestorsScrollTop() {\n        var scrollTop = 0,\n          p = _sd.appendTarget.parentNode;\n        while (p) {\n          scrollTop += p.scrollTop || 0;\n          p = p.parentNode;\n        }\n        return scrollTop;\n      }\n      if (!this.state.dropdown.visible) return;\n      if (positionTo == 'text') {\n        rect = getCaretGlobalPosition();\n        bottom = rect.bottom;\n        top = rect.top;\n        left = rect.left;\n        width = 'auto';\n      } else {\n        parentsPositions = getParentsPositions(_sd.appendTarget);\n        rect = ddTarget.getBoundingClientRect();\n        top = rect.top - parentsPositions.top;\n        bottom = rect.bottom - 1 - parentsPositions.top;\n        left = rect.left - parentsPositions.left;\n        width = rect.width + 'px';\n      }\n\n      // if the \"append target\" isn't the default, correct the `top` variable by ignoring any scrollTop of the target's Ancestors\n      if (!isDefaultAppendTarget) {\n        let accumulatedAncestorsScrollTop = getAccumulatedAncestorsScrollTop();\n        top += accumulatedAncestorsScrollTop;\n        bottom += accumulatedAncestorsScrollTop;\n      }\n      top = Math.floor(top);\n      bottom = Math.ceil(bottom);\n      placeAbove = placeAbove === undefined ? viewportHeight - rect.bottom < ddHeight : placeAbove;\n\n      // flip vertically if there is no space for the dropdown below the input\n      ddElm.style.cssText = \"left:\" + (left + window.pageXOffset) + \"px; width:\" + width + \";\" + (placeAbove ? \"top: \" + (top + appendTargetScrollTop) + \"px\" : \"top: \" + (bottom + appendTargetScrollTop) + \"px\");\n      ddElm.setAttribute('placement', placeAbove ? \"top\" : \"bottom\");\n      ddElm.setAttribute('position', positionTo);\n    },\n    events: {\n      /**\r\n       * Events should only be binded when the dropdown is rendered and removed when isn't\r\n       * because there might be multiple Tagify instances on a certain page\r\n       * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]\r\n       */\n      binding() {\n        let bindUnbind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        // references to the \".bind()\" methods must be saved so they could be unbinded later\n        var _CB = this.dropdown.events.callbacks,\n          // callback-refs\n          _CBR = this.listeners.dropdown = this.listeners.dropdown || {\n            position: this.dropdown.position.bind(this, null),\n            onKeyDown: _CB.onKeyDown.bind(this),\n            onMouseOver: _CB.onMouseOver.bind(this),\n            onMouseLeave: _CB.onMouseLeave.bind(this),\n            onClick: _CB.onClick.bind(this),\n            onScroll: _CB.onScroll.bind(this)\n          },\n          action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n        if (this.settings.dropdown.position != 'manual') {\n          document[action]('scroll', _CBR.position, true);\n          window[action]('resize', _CBR.position);\n          window[action]('keydown', _CBR.onKeyDown);\n        }\n        this.DOM.dropdown[action]('mouseover', _CBR.onMouseOver);\n        this.DOM.dropdown[action]('mouseleave', _CBR.onMouseLeave);\n        this.DOM.dropdown[action]('mousedown', _CBR.onClick);\n        this.DOM.dropdown.content[action]('scroll', _CBR.onScroll);\n      },\n      callbacks: {\n        onKeyDown(e) {\n          // ignore keys during IME composition\n          if (!this.state.hasFocus || this.state.composing) return;\n\n          // get the \"active\" element, and if there was none (yet) active, use first child\n          var selectedElm = this.DOM.dropdown.querySelector(this.settings.classNames.dropdownItemActiveSelector),\n            selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm);\n          switch (e.key) {\n            case 'ArrowDown':\n            case 'ArrowUp':\n            case 'Down': // >IE11\n            case 'Up':\n              {\n                // >IE11\n                e.preventDefault();\n                var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n                  actionUp = e.key == 'ArrowUp' || e.key == 'Up';\n                if (selectedElm) {\n                  selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp);\n                }\n\n                // if no element was found OR current item is not a \"real\" item, loop\n                if (!selectedElm || !selectedElm.matches(this.settings.classNames.dropdownItemSelector)) {\n                  selectedElm = dropdownItems[actionUp ? dropdownItems.length - 1 : 0];\n                }\n                this.dropdown.highlightOption(selectedElm, true);\n                // selectedElm.scrollIntoView({inline: 'nearest', behavior: 'smooth'})\n                break;\n              }\n            case 'Escape':\n            case 'Esc':\n              // IE11\n              this.dropdown.hide();\n              break;\n            case 'ArrowRight':\n              if (this.state.actions.ArrowLeft) return;\n            case 'Tab':\n              {\n                // in mix-mode, treat arrowRight like Enter key, so a tag will be created\n                if (this.settings.mode != 'mix' && selectedElm && !this.settings.autoComplete.rightKey && !this.state.editing) {\n                  e.preventDefault(); // prevents blur so the autocomplete suggestion will not become a tag\n                  var value = this.dropdown.getMappedValue(selectedElmData);\n                  this.input.autocomplete.set.call(this, value);\n                  return false;\n                }\n                return true;\n              }\n            case 'Enter':\n              {\n                e.preventDefault();\n                this.settings.hooks.suggestionClick(e, {\n                  tagify: this,\n                  tagData: selectedElmData,\n                  suggestionElm: selectedElm\n                }).then(() => {\n                  if (selectedElm) {\n                    this.dropdown.selectOption(selectedElm);\n                    // highlight next option\n                    selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp);\n                    this.dropdown.highlightOption(selectedElm);\n                    return;\n                  } else this.dropdown.hide();\n                  if (this.settings.mode != 'mix') this.addTags(this.state.inputText.trim(), true);\n                }).catch(err => err);\n                break;\n              }\n            case 'Backspace':\n              {\n                if (this.settings.mode == 'mix' || this.state.editing.scope) return;\n                const value = this.input.raw.call(this);\n                if (value == \"\" || value.charCodeAt(0) == 8203) {\n                  if (this.settings.backspace === true) this.removeTags();else if (this.settings.backspace == 'edit') setTimeout(this.editTag.bind(this), 0);\n                }\n              }\n          }\n        },\n        onMouseOver(e) {\n          var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector);\n          // event delegation check\n          ddItem && this.dropdown.highlightOption(ddItem);\n        },\n        onMouseLeave(e) {\n          // de-highlight any previously highlighted option\n          this.dropdown.highlightOption();\n        },\n        onClick(e) {\n          if (e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content) return; // allow only mouse left-clicks\n\n          var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector),\n            selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm);\n\n          // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't run\n          this.state.actions.selectOption = true;\n          setTimeout(() => this.state.actions.selectOption = false, 50);\n          this.settings.hooks.suggestionClick(e, {\n            tagify: this,\n            tagData: selectedElmData,\n            suggestionElm: selectedElm\n          }).then(() => {\n            if (selectedElm) this.dropdown.selectOption(selectedElm, e);else this.dropdown.hide();\n          }).catch(err => console.warn(err));\n        },\n        onScroll(e) {\n          var elm = e.target,\n            pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;\n          this.trigger(\"dropdown:scroll\", {\n            percentage: Math.round(pos)\n          });\n        }\n      }\n    },\n    /**\r\n     * Given a suggestion-item, return the data associated with it\r\n     * @param {HTMLElement} tagElm\r\n     * @returns Object\r\n     */\n    getSuggestionDataByNode(tagElm) {\n      var value = tagElm && tagElm.getAttribute('value');\n      return this.suggestedListItems.find(item => item.value == value) || null;\n    },\n    getNextOrPrevOption(selected) {\n      let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n        selectedIdx = dropdownItems.findIndex(item => item === selected);\n      return next ? dropdownItems[selectedIdx + 1] : dropdownItems[selectedIdx - 1];\n    },\n    /**\r\n     * mark the currently active suggestion option\r\n     * @param {Object}  elm            option DOM node\r\n     * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), aut-scroll to always show the highlighted element\r\n     */\n    highlightOption(elm, adjustScroll) {\n      var className = this.settings.classNames.dropdownItemActive,\n        itemData;\n\n      // focus casues a bug in Firefox with the placeholder been shown on the input element\n      // if( this.settings.dropdown.position != 'manual' )\n      //     elm.focus();\n\n      if (this.state.ddItemElm) {\n        this.state.ddItemElm.classList.remove(className);\n        this.state.ddItemElm.removeAttribute(\"aria-selected\");\n      }\n      if (!elm) {\n        this.state.ddItemData = null;\n        this.state.ddItemElm = null;\n        this.input.autocomplete.suggest.call(this);\n        return;\n      }\n      itemData = this.dropdown.getSuggestionDataByNode(elm);\n      this.state.ddItemData = itemData;\n      this.state.ddItemElm = elm;\n\n      // this.DOM.dropdown.querySelectorAll(\".\" + this.settings.classNames.dropdownItemActive).forEach(activeElm => activeElm.classList.remove(className));\n      elm.classList.add(className);\n      elm.setAttribute(\"aria-selected\", true);\n      if (adjustScroll) elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight;\n\n      // Try to autocomplete the typed value with the currently highlighted dropdown item\n      if (this.settings.autoComplete) {\n        this.input.autocomplete.suggest.call(this, itemData);\n        this.dropdown.position(); // suggestions might alter the height of the tagify wrapper because of unkown suggested term length that could drop to the next line\n      }\n    },\n\n    /**\r\n     * Create a tag from the currently active suggestion option\r\n     * @param {Object} elm  DOM node to select\r\n     * @param {Object} event The original Click event, if available (since keyboard ENTER key also triggers this method)\r\n     */\n    selectOption(elm, event) {\n      var _this$settings$dropdo = this.settings.dropdown,\n        clearOnSelect = _this$settings$dropdo.clearOnSelect,\n        closeOnSelect = _this$settings$dropdo.closeOnSelect;\n      if (!elm) {\n        this.addTags(this.state.inputText, true);\n        closeOnSelect && this.dropdown.hide();\n        return;\n      }\n      event = event || {};\n\n      // if in edit-mode, do not continue but instead replace the tag's text.\n      // the scenario is that \"addTags\" was called from a dropdown suggested option selected while editing\n\n      var value = elm.getAttribute('value'),\n        isNoMatch = value == 'noMatch',\n        tagData = this.suggestedListItems.find(item => (item.value || item) == value);\n\n      // The below event must be triggered, regardless of anything else which might go wrong\n      this.trigger('dropdown:select', {\n        data: tagData,\n        elm,\n        event\n      });\n      if (!value || !tagData && !isNoMatch) {\n        closeOnSelect && setTimeout(this.dropdown.hide.bind(this));\n        return;\n      }\n      if (this.state.editing) {\n        // normalizing value, because \"tagData\" might be a string, and therefore will not be able to extend the object\n        this.onEditTagDone(null, extend({\n          __isValid: true\n        }, this.normalizeTags([tagData])[0]));\n      }\n      // Tagify instances should re-focus to the input element once an option was selected, to allow continuous typing\n      else {\n        this[this.settings.mode == 'mix' ? \"addMixTags\" : \"addTags\"]([tagData || this.input.raw.call(this)], clearOnSelect);\n      }\n\n      // todo: consider not doing this on mix-mode\n      if (!this.DOM.input.parentNode) return;\n      setTimeout(() => {\n        this.DOM.input.focus();\n        this.toggleFocusClass(true);\n        this.setRangeAtStartEnd(false, this.DOM.input);\n      });\n      closeOnSelect && setTimeout(this.dropdown.hide.bind(this));\n\n      // hide selected suggestion\n      elm.addEventListener('transitionend', () => {\n        this.dropdown.fillHeaderFooter();\n        setTimeout(() => elm.remove(), 100);\n      }, {\n        once: true\n      });\n      elm.classList.add(this.settings.classNames.dropdownItemHidden);\n    },\n    // adds all the suggested items, including the ones which are not currently rendered,\n    // unless specified otherwise (by the \"onlyRendered\" argument)\n    selectAll(onlyRendered) {\n      // having suggestedListItems with items messes with \"normalizeTags\" when wanting\n      // to add all tags\n      this.suggestedListItems.length = 0;\n      this.dropdown.hide();\n      this.dropdown.filterListItems('');\n      var tagsToAdd = this.dropdown.filterListItems('');\n      if (!onlyRendered) tagsToAdd = this.state.dropdown.suggestions;\n\n      // some whitelist items might have already been added as tags so when addings all of them,\n      // skip adding already-added ones, so best to use \"filterListItems\" method over \"settings.whitelist\"\n      this.addTags(tagsToAdd, true);\n      return this;\n    },\n    /**\r\n     * returns an HTML string of the suggestions' list items\r\n     * @param {String} value string to filter the whitelist by\r\n     * @param {Object} options \"exact\" - for exact complete match\r\n     * @return {Array} list of filtered whitelist items according to the settings provided and current value\r\n     */\n    filterListItems(value, options) {\n      var _s = this.settings,\n        _sd = _s.dropdown,\n        options = options || {},\n        list = [],\n        exactMatchesList = [],\n        whitelist = _s.whitelist,\n        suggestionsCount = _sd.maxItems >= 0 ? _sd.maxItems : Infinity,\n        searchKeys = _sd.searchKeys,\n        whitelistItem,\n        valueIsInWhitelist,\n        searchBy,\n        isDuplicate,\n        niddle,\n        i = 0;\n      value = _s.mode == 'select' && this.value.length && this.value[0][_s.tagTextProp] == value ? '' // do not filter if the tag, which is already selecetd in \"select\" mode, is the same as the typed text\n      : value;\n      if (!value || !searchKeys.length) {\n        list = _sd.includeSelectedTags ? whitelist : whitelist.filter(item => !this.isTagDuplicate(isObject(item) ? item.value : item)); // don't include tags which have already been added.\n\n        this.state.dropdown.suggestions = list;\n        return list.slice(0, suggestionsCount); // respect \"maxItems\" dropdown setting\n      }\n\n      niddle = _sd.caseSensitive ? \"\" + value : (\"\" + value).toLowerCase();\n\n      // checks if ALL of the words in the search query exists in the current whitelist item, regardless of their order\n      function stringHasAll(s, query) {\n        return query.toLowerCase().split(' ').every(q => s.includes(q.toLowerCase()));\n      }\n      for (; i < whitelist.length; i++) {\n        let startsWithMatch, exactMatch;\n        whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : {\n          value: whitelist[i]\n        }; //normalize value as an Object\n\n        let itemWithoutSearchKeys = !Object.keys(whitelistItem).some(k => searchKeys.includes(k)),\n          _searchKeys = itemWithoutSearchKeys ? [\"value\"] : searchKeys;\n        if (_sd.fuzzySearch && !options.exact) {\n          searchBy = _searchKeys.reduce((values, k) => values + \" \" + (whitelistItem[k] || \"\"), \"\").toLowerCase().trim();\n          if (_sd.accentedSearch) {\n            searchBy = unaccent(searchBy);\n            niddle = unaccent(niddle);\n          }\n          startsWithMatch = searchBy.indexOf(niddle) == 0;\n          exactMatch = searchBy === niddle;\n          valueIsInWhitelist = stringHasAll(searchBy, niddle);\n        } else {\n          startsWithMatch = true;\n          valueIsInWhitelist = _searchKeys.some(k => {\n            var v = '' + (whitelistItem[k] || ''); // if key exists, cast to type String\n\n            if (_sd.accentedSearch) {\n              v = unaccent(v);\n              niddle = unaccent(niddle);\n            }\n            if (!_sd.caseSensitive) v = v.toLowerCase();\n            exactMatch = v === niddle;\n            return options.exact ? v === niddle : v.indexOf(niddle) == 0;\n          });\n        }\n        isDuplicate = !_sd.includeSelectedTags && this.isTagDuplicate(isObject(whitelistItem) ? whitelistItem.value : whitelistItem);\n\n        // match for the value within each \"whitelist\" item\n        if (valueIsInWhitelist && !isDuplicate) if (exactMatch && startsWithMatch) exactMatchesList.push(whitelistItem);else if (_sd.sortby == 'startsWith' && startsWithMatch) list.unshift(whitelistItem);else list.push(whitelistItem);\n      }\n      this.state.dropdown.suggestions = exactMatchesList.concat(list);\n\n      // custom sorting function\n      return typeof _sd.sortby == 'function' ? _sd.sortby(exactMatchesList.concat(list), niddle) : exactMatchesList.concat(list).slice(0, suggestionsCount);\n    },\n    /**\r\n     * Returns the final value of a tag data (object) with regards to the \"mapValueTo\" dropdown setting\r\n     * @param {Object} tagData\r\n     * @returns\r\n     */\n    getMappedValue(tagData) {\n      var mapValueTo = this.settings.dropdown.mapValueTo,\n        value = mapValueTo ? typeof mapValueTo == 'function' ? mapValueTo(tagData) : tagData[mapValueTo] || tagData.value : tagData.value;\n      return value;\n    },\n    /**\r\n     * Creates the dropdown items' HTML\r\n     * @param  {Array} sugegstionsList  [Array of Objects]\r\n     * @return {String}\r\n     */\n    createListHTML(sugegstionsList) {\n      return extend([], sugegstionsList).map((suggestion, idx) => {\n        if (typeof suggestion == 'string' || typeof suggestion == 'number') suggestion = {\n          value: suggestion\n        };\n        var mappedValue = this.dropdown.getMappedValue(suggestion);\n        mappedValue = typeof mappedValue == 'string' ? escapeHTML(mappedValue) : mappedValue;\n        return this.settings.templates.dropdownItem.apply(this, [_objectSpread2(_objectSpread2({}, suggestion), {}, {\n          mappedValue\n        }), this]);\n      }).join(\"\");\n    }\n  };\n\n  const VERSION = 1; // current version of persisted data. if code change breaks persisted data, verison number should be bumped.\n  const STORE_KEY = '@yaireo/tagify/';\n  const getPersistedData = id => key => {\n    // if \"persist\" is \"false\", do not save to localstorage\n    let customKey = '/' + key,\n      persistedData,\n      versionMatch = localStorage.getItem(STORE_KEY + id + '/v', VERSION) == VERSION;\n    if (versionMatch) {\n      try {\n        persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]);\n      } catch (err) {}\n    }\n    return persistedData;\n  };\n  const setPersistedData = id => {\n    if (!id) return () => {};\n\n    // for storage invalidation\n    localStorage.setItem(STORE_KEY + id + '/v', VERSION);\n    return (data, key) => {\n      let customKey = '/' + key,\n        persistedData = JSON.stringify(data);\n      if (data && key) {\n        localStorage.setItem(STORE_KEY + id + customKey, persistedData);\n        dispatchEvent(new Event('storage'));\n      }\n    };\n  };\n  const clearPersistedData = id => key => {\n    const base = STORE_KEY + '/' + id + '/';\n\n    // delete specific key in the storage\n    if (key) localStorage.removeItem(base + key);\n\n    // delete all keys in the storage with a specific tagify id\n    else {\n      for (let k in localStorage) if (k.includes(base)) localStorage.removeItem(k);\n    }\n  };\n\n  var TEXTS = {\n    empty: \"empty\",\n    exceed: \"number of tags exceeded\",\n    pattern: \"pattern mismatch\",\n    duplicate: \"already exists\",\n    notAllowed: \"not allowed\"\n  };\n\n  var templates = {\n    /**\r\n     *\r\n     * @param {DOM Object} input     Original input DOm element\r\n     * @param {Object}     settings  Tagify instance settings Object\r\n     */\n    wrapper(input, _s) {\n      return `<tags class=\"${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + \"Mode\"]}` : \"\"} ${input.className}\"\n                    ${_s.readonly ? 'readonly' : ''}\n                    ${_s.disabled ? 'disabled' : ''}\n                    ${_s.required ? 'required' : ''}\n                    ${_s.mode === 'select' ? \"spellcheck='false'\" : ''}\n                    tabIndex=\"-1\">\n            <span ${!_s.readonly && _s.userInput ? 'contenteditable' : ''} tabIndex=\"0\" data-placeholder=\"${_s.placeholder || '&#8203;'}\" aria-placeholder=\"${_s.placeholder || ''}\"\n                class=\"${_s.classNames.input}\"\n                role=\"textbox\"\n                aria-autocomplete=\"both\"\n                aria-multiline=\"${_s.mode == 'mix' ? true : false}\"></span>\n                &#8203;\n        </tags>`;\n    },\n    tag(tagData, _ref) {\n      let _s = _ref.settings;\n      return `<tag title=\"${tagData.title || tagData.value}\"\n                    contenteditable='false'\n                    spellcheck='false'\n                    tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\"\n                    class=\"${_s.classNames.tag} ${tagData.class || \"\"}\"\n                    ${this.getAttributes(tagData)}>\n            <x title='' class=\"${_s.classNames.tagX}\" role='button' aria-label='remove tag'></x>\n            <div>\n                <span class=\"${_s.classNames.tagText}\">${tagData[_s.tagTextProp] || tagData.value}</span>\n            </div>\n        </tag>`;\n    },\n    dropdown(settings) {\n      var _sd = settings.dropdown,\n        isManual = _sd.position == 'manual',\n        className = `${settings.classNames.dropdown}`;\n      return `<div class=\"${isManual ? \"\" : className} ${_sd.classname}\" role=\"listbox\" aria-labelledby=\"dropdown\">\n                    <div data-selector='tagify-suggestions-wrapper' class=\"${settings.classNames.dropdownWrapper}\"></div>\n                </div>`;\n    },\n    dropdownContent(HTMLContent) {\n      var _s = this.settings,\n        suggestions = this.state.dropdown.suggestions;\n      return `\n            ${_s.templates.dropdownHeader.call(this, suggestions)}\n            ${HTMLContent}\n            ${_s.templates.dropdownFooter.call(this, suggestions)}\n        `;\n    },\n    dropdownItem(item) {\n      return `<div ${this.getAttributes(item)}\n                    class='${this.settings.classNames.dropdownItem} ${item.class ? item.class : \"\"}'\n                    tabindex=\"0\"\n                    role=\"option\">${item.mappedValue || item.value}</div>`;\n    },\n    /**\r\n     * @param {Array} suggestions An array of all the matched suggested items, including those which were sliced away due to the \"dropdown.maxItems\" setting\r\n     */\n    dropdownHeader(suggestions) {\n      return `<header data-selector='tagify-suggestions-header' class=\"${this.settings.classNames.dropdownHeader}\"></header>`;\n    },\n    dropdownFooter(suggestions) {\n      var hasMore = suggestions.length - this.settings.dropdown.maxItems;\n      return hasMore > 0 ? `<footer data-selector='tagify-suggestions-footer' class=\"${this.settings.classNames.dropdownFooter}\">\n                ${hasMore} more items. Refine your search.\n            </footer>` : '';\n    },\n    dropdownItemNoMatch: null\n  };\n\n  function EventDispatcher(instance) {\n    // Create a DOM EventTarget object\n    var target = document.createTextNode('');\n    function addRemove(op, events, cb) {\n      if (cb) events.split(/\\s+/g).forEach(name => target[op + 'EventListener'].call(target, name, cb));\n    }\n\n    // Pass EventTarget interface calls to DOM EventTarget object\n    return {\n      off(events, cb) {\n        addRemove('remove', events, cb);\n        return this;\n      },\n      on(events, cb) {\n        if (cb && typeof cb == 'function') addRemove('add', events, cb);\n        return this;\n      },\n      trigger(eventName, data, opts) {\n        var e;\n        opts = opts || {\n          cloneData: true\n        };\n        if (!eventName) return;\n        if (instance.settings.isJQueryPlugin) {\n          if (eventName == 'remove') eventName = 'removeTag'; // issue #222\n          jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data]);\n        } else {\n          try {\n            var eventData = typeof data === 'object' ? data : {\n              value: data\n            };\n            eventData = opts.cloneData ? extend({}, eventData) : eventData;\n            eventData.tagify = this;\n            if (data.event) eventData.event = this.cloneEvent(data.event);\n\n            // TODO: move the below to the \"extend\" function\n            if (data instanceof Object) for (var prop in data) if (data[prop] instanceof HTMLElement) eventData[prop] = data[prop];\n            e = new CustomEvent(eventName, {\n              \"detail\": eventData\n            });\n          } catch (err) {\n            console.warn(err);\n          }\n          target.dispatchEvent(e);\n        }\n      }\n    };\n  }\n\n  var deleteBackspaceTimeout;\n  function triggerChangeEvent() {\n    if (this.settings.mixMode.integrated) return;\n    var inputElm = this.DOM.originalInput,\n      changed = this.state.lastOriginalValueReported !== inputElm.value,\n      event = new CustomEvent(\"change\", {\n        bubbles: true\n      }); // must use \"CustomEvent\" and not \"Event\" to support IE\n\n    if (!changed) return;\n\n    // must apply this BEFORE triggering the simulated event\n    this.state.lastOriginalValueReported = inputElm.value;\n\n    // React hack: https://github.com/facebook/react/issues/11488\n    event.simulated = true;\n    if (inputElm._valueTracker) inputElm._valueTracker.setValue(Math.random());\n    inputElm.dispatchEvent(event);\n\n    // also trigger a Tagify event\n    this.trigger(\"change\", this.state.lastOriginalValueReported);\n\n    // React, for some reason, clears the input's value after \"dispatchEvent\" is fired\n    inputElm.value = this.state.lastOriginalValueReported;\n  }\n  var events = {\n    // bind custom events which were passed in the settings\n    customBinding() {\n      this.customEventsList.forEach(name => {\n        this.on(name, this.settings.callbacks[name]);\n      });\n    },\n    binding() {\n      let bindUnbind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var _CB = this.events.callbacks,\n        _CBR,\n        action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n      // do not allow the main events to be bound more than once\n      if (this.state.mainEvents && bindUnbind) return;\n\n      // set the binding state of the main events, so they will not be bound more than once\n      this.state.mainEvents = bindUnbind;\n\n      // everything inside gets executed only once-per instance\n      if (bindUnbind && !this.listeners.main) {\n        this.events.bindGlobal.call(this);\n        if (this.settings.isJQueryPlugin) jQuery(this.DOM.originalInput).on('tagify.removeAllTags', this.removeAllTags.bind(this));\n      }\n\n      // setup callback references so events could be removed later\n      _CBR = this.listeners.main = this.listeners.main || {\n        focus: ['input', _CB.onFocusBlur.bind(this)],\n        keydown: ['input', _CB.onKeydown.bind(this)],\n        click: ['scope', _CB.onClickScope.bind(this)],\n        dblclick: ['scope', _CB.onDoubleClickScope.bind(this)],\n        paste: ['input', _CB.onPaste.bind(this)],\n        drop: ['input', _CB.onDrop.bind(this)],\n        compositionstart: ['input', _CB.onCompositionStart.bind(this)],\n        compositionend: ['input', _CB.onCompositionEnd.bind(this)]\n      };\n      for (var eventName in _CBR) {\n        this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);\n      }\n\n      // listen to original input changes (unfortunetly this is the best way...)\n      // https://stackoverflow.com/a/1949416/104380\n      clearInterval(this.listeners.main.originalInputValueObserverInterval);\n      this.listeners.main.originalInputValueObserverInterval = setInterval(_CB.observeOriginalInputValue.bind(this), 500);\n\n      // observers\n      var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this));\n\n      // cleaup just-in-case\n      inputMutationObserver.disconnect();\n\n      // observe stuff\n      if (this.settings.mode == 'mix') inputMutationObserver.observe(this.DOM.input, {\n        childList: true\n      });\n    },\n    bindGlobal(unbind) {\n      var _CB = this.events.callbacks,\n        action = unbind ? 'removeEventListener' : 'addEventListener',\n        e;\n      if (!unbind && this.listeners.global) return; // do not re-bind\n\n      // these events are global event should never be unbinded, unless the instance is destroyed:\n      this.listeners.global = this.listeners && this.listeners.global || [{\n        type: this.isIE ? 'keydown' : 'input',\n        // IE cannot register \"input\" events on contenteditable elements, so the \"keydown\" should be used instead..\n        target: this.DOM.input,\n        cb: _CB[this.isIE ? 'onInputIE' : 'onInput'].bind(this)\n      }, {\n        type: 'keydown',\n        target: window,\n        cb: _CB.onWindowKeyDown.bind(this)\n      }, {\n        type: 'blur',\n        target: this.DOM.input,\n        cb: _CB.onFocusBlur.bind(this)\n      }];\n      for (e of this.listeners.global) e.target[action](e.type, e.cb);\n    },\n    unbindGlobal() {\n      this.events.bindGlobal.call(this, true);\n    },\n    /**\r\n     * DOM events callbacks\r\n     */\n    callbacks: {\n      onFocusBlur(e) {\n        var _s = this.settings,\n          text = e.target ? this.trim(e.target.textContent) : '',\n          // a string\n          currentDisplayValue = this.value?.[0]?.[_s.tagTextProp],\n          type = e.type,\n          ddEnabled = _s.dropdown.enabled >= 0,\n          eventData = {\n            relatedTarget: e.relatedTarget\n          },\n          isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect),\n          isTargetAddNewBtn = this.state.actions.addNew && ddEnabled,\n          isRelatedTargetX = e.relatedTarget && isNodeTag.call(this, e.relatedTarget) && this.DOM.scope.contains(e.relatedTarget),\n          shouldAddTags;\n        if (type == 'blur') {\n          if (e.relatedTarget === this.DOM.scope) {\n            this.dropdown.hide();\n            this.DOM.input.focus();\n            return;\n          }\n          this.postUpdate();\n          _s.onChangeAfterBlur && this.triggerChangeEvent();\n        }\n        if (isTargetSelectOption || isTargetAddNewBtn) return;\n        this.state.hasFocus = type == \"focus\" ? +new Date() : false;\n        this.toggleFocusClass(this.state.hasFocus);\n        if (_s.mode == 'mix') {\n          if (type == \"focus\") {\n            this.trigger(\"focus\", eventData);\n          } else if (e.type == \"blur\") {\n            this.trigger(\"blur\", eventData);\n            this.loading(false);\n            this.dropdown.hide();\n            // reset state which needs reseting\n            this.state.dropdown.visible = undefined;\n            this.setStateSelection();\n          }\n          return;\n        }\n        if (type == \"focus\") {\n          this.trigger(\"focus\", eventData);\n          //  e.target.classList.remove('placeholder');\n          if (_s.dropdown.enabled === 0 || !_s.userInput) {\n            // && _s.mode != \"select\"\n            this.dropdown.show(this.value.length ? '' : undefined);\n          }\n          return;\n        } else if (type == \"blur\") {\n          this.trigger(\"blur\", eventData);\n          this.loading(false);\n\n          // when clicking the X button of a selected tag, it is unwanted for it to be added back\n          // again in a few more lines of code (shouldAddTags && addTags)\n          if (_s.mode == 'select') {\n            if (isRelatedTargetX) {\n              this.removeTags();\n              text = '';\n            }\n\n            // if nothing has changed (same display value), do not add a tag\n            if (currentDisplayValue === text) text = '';\n          }\n          shouldAddTags = text && !this.state.actions.selectOption && _s.addTagOnBlur;\n\n          // do not add a tag if \"selectOption\" action was just fired (this means a tag was just added from the dropdown)\n          shouldAddTags && this.addTags(text, true);\n        }\n        this.DOM.input.removeAttribute('style');\n        this.dropdown.hide();\n      },\n      onCompositionStart(e) {\n        this.state.composing = true;\n      },\n      onCompositionEnd(e) {\n        this.state.composing = false;\n      },\n      onWindowKeyDown(e) {\n        var focusedElm = document.activeElement,\n          isTag = isNodeTag.call(this, focusedElm),\n          isBelong = isTag && this.DOM.scope.contains(document.activeElement),\n          nextTag;\n        if (!isBelong) return;\n        nextTag = focusedElm.nextElementSibling;\n        switch (e.key) {\n          // remove tag if has focus\n          case 'Backspace':\n            {\n              if (!this.settings.readonly) {\n                this.removeTags(focusedElm);\n                (nextTag ? nextTag : this.DOM.input).focus();\n              }\n              break;\n            }\n\n          // edit tag if has focus\n          case 'Enter':\n            {\n              setTimeout(this.editTag.bind(this), 0, focusedElm);\n              break;\n            }\n        }\n      },\n      onKeydown(e) {\n        var _s = this.settings;\n\n        // ignore keys during IME composition or when user input is not allowed\n        if (this.state.composing || !_s.userInput) return;\n        if (_s.mode == 'select' && _s.enforceWhitelist && this.value.length && e.key != 'Tab') {\n          e.preventDefault();\n        }\n        var s = this.trim(e.target.textContent);\n        this.trigger(\"keydown\", {\n          event: e\n        });\n\n        /**\r\n         * ONLY FOR MIX-MODE:\r\n         */\n        if (_s.mode == 'mix') {\n          switch (e.key) {\n            case 'Left':\n            case 'ArrowLeft':\n              {\n                // when left arrow was pressed, set a flag so when the dropdown is shown, right-arrow will be ignored\n                // because it seems likely the user wishes to use the arrows to move the caret\n                this.state.actions.ArrowLeft = true;\n                break;\n              }\n            case 'Delete':\n            case 'Backspace':\n              {\n                if (this.state.editing) return;\n                var sel = document.getSelection(),\n                  deleteKeyTagDetected = e.key == 'Delete' && sel.anchorOffset == (sel.anchorNode.length || 0),\n                  prevAnchorSibling = sel.anchorNode.previousSibling,\n                  isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling;\n                  decode(this.DOM.input.innerHTML);\n                  var lastTagElems = this.getTagElms(),\n                  //  isCaretInsideTag = sel.anchorNode.parentNode('.' + _s.classNames.tag),\n                  tagBeforeCaret,\n                  tagElmToBeDeleted,\n                  firstTextNodeBeforeTag;\n                if (_s.backspace == 'edit' && isCaretAfterTag) {\n                  tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;\n                  setTimeout(this.editTag.bind(this), 0, tagBeforeCaret); // timeout is needed to the last cahacrter in the edited tag won't get deleted\n                  e.preventDefault(); // needed so the tag elm won't get deleted\n                  return;\n                }\n                if (isChromeAndroidBrowser() && isCaretAfterTag instanceof Element) {\n                  firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag);\n                  if (!isCaretAfterTag.hasAttribute('readonly')) isCaretAfterTag.remove(); // since this is Chrome, can safetly use this \"new\" DOM API\n\n                  // Android-Chrome wrongly hides the keyboard, and loses focus,\n                  // so this hack below is needed to regain focus at the correct place:\n                  this.DOM.input.focus();\n                  setTimeout(() => {\n                    this.placeCaretAfterNode(firstTextNodeBeforeTag);\n                    this.DOM.input.click();\n                  });\n                  return;\n                }\n                if (sel.anchorNode.nodeName == 'BR') return;\n                if ((deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1) {\n                  if (sel.anchorOffset == 0)\n                    // caret is at the very begining, before a tag\n                    tagElmToBeDeleted = deleteKeyTagDetected // delete key pressed\n                    ? lastTagElems[0] : null;else tagElmToBeDeleted = lastTagElems[Math.min(lastTagElems.length, sel.anchorOffset) - 1];\n\n                  // find out if a tag *might* be a candidate for deletion, and if so, which\n                } else if (deleteKeyTagDetected) tagElmToBeDeleted = sel.anchorNode.nextElementSibling;else if (isCaretAfterTag instanceof Element) tagElmToBeDeleted = isCaretAfterTag;\n\n                // tagElm.hasAttribute('readonly')\n                if (sel.anchorNode.nodeType == 3 &&\n                // node at caret location is a Text node\n                !sel.anchorNode.nodeValue &&\n                // has some text\n                sel.anchorNode.previousElementSibling)\n                  // text node has a Tag node before it\n                  e.preventDefault();\n\n                // if backspace not allowed, do nothing\n                // TODO: a better way to detect if nodes were deleted is to simply check the \"this.value\" before & after\n                if ((isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace) {\n                  e.preventDefault();\n                  return;\n                }\n                if (sel.type != 'Range' && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != 'Delete') {\n                  e.preventDefault();\n                  return;\n                }\n                if (sel.type != 'Range' && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute('readonly')) {\n                  // allows the continuation of deletion by placing the caret on the first previous textNode.\n                  // since a few readonly-tags might be one after the other, iteration is needed:\n\n                  this.placeCaretAfterNode(getfirstTextNode(tagElmToBeDeleted));\n                  return;\n                }\n\n                // update regarding https://github.com/yairEO/tagify/issues/762#issuecomment-786464317:\n                // the bug described is more severe than the fix below, therefore I disable the fix until a solution\n                // is found which work well for both cases.\n                // -------\n                // nodeType is \"1\" only when the caret is at the end after last tag (no text after), or before first first (no text before)\n                /*\r\n                if( this.isFirefox && sel.anchorNode.nodeType == 1 && sel.anchorOffset != 0 ){\r\n                    this.removeTags() // removes last tag by default if no parameter supplied\r\n                    // place caret inside last textNode, if exist. it's an annoying bug only in FF,\r\n                    // if the last tag is removed, and there is a textNode before it, the caret is not placed at its end\r\n                    this.placeCaretAfterNode( setRangeAtStartEnd(false, this.DOM.input) )\r\n                }\r\n                */\n\n                clearTimeout(deleteBackspaceTimeout);\n                // a minimum delay is needed before the node actually gets detached from the document (don't know why),\n                // to know exactly which tag was deleted. This is the easiest way of knowing besides using MutationObserver\n                deleteBackspaceTimeout = setTimeout(() => {\n                  var sel = document.getSelection();\n                    decode(this.DOM.input.innerHTML);\n                    !deleteKeyTagDetected && sel.anchorNode.previousSibling;\n\n                  // fixes #384, where the first and only tag will not get removed with backspace\n                  /*\r\n                   * [UPDATE DEC 3, 22] SEEMS BELOEW CODE IS NOT NEEDED ANY MORE\r\n                   *\r\n                  if( currentValue.length > lastInputValue.length && prevElm ){\r\n                      if( isNodeTag.call(this, prevElm) && !prevElm.hasAttribute('readonly') ){\r\n                          this.removeTags(prevElm)\r\n                          this.fixFirefoxLastTagNoCaret()\r\n                            // the above \"removeTag\" methods removes the tag with a transition. Chrome adds a <br> element for some reason at this stage\r\n                          if( this.DOM.input.children.length == 2 && this.DOM.input.children[1].tagName == \"BR\" ){\r\n                              this.DOM.input.innerHTML = \"\"\r\n                              this.value.length = 0\r\n                              return true\r\n                          }\r\n                      }\r\n                        else\r\n                          prevElm.remove()\r\n                  }\r\n                  */\n\n                  // find out which tag(s) were deleted and trigger \"remove\" event\n                  // iterate over the list of tags still in the document and then filter only those from the \"this.value\" collection\n                  this.value = [].map.call(lastTagElems, (node, nodeIdx) => {\n                    var tagData = getSetTagData(node);\n\n                    // since readonly cannot be removed (it's technically resurrected if removed somehow)\n                    if (node.parentNode || tagData.readonly) return tagData;else this.trigger('remove', {\n                      tag: node,\n                      index: nodeIdx,\n                      data: tagData\n                    });\n                  }).filter(n => n); // remove empty items in the mapped array\n                }, 20); // Firefox needs this higher duration for some reason or things get buggy when deleting text from the end\n                break;\n              }\n            // currently commented to allow new lines in mixed-mode\n            // case 'Enter' :\n            //     // e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n          }\n\n          return true;\n        }\n        switch (e.key) {\n          case 'Backspace':\n            if (_s.mode == 'select' && _s.enforceWhitelist && this.value.length) this.removeTags();else if (!this.state.dropdown.visible || _s.dropdown.position == 'manual') {\n              if (e.target.textContent == \"\" || s.charCodeAt(0) == 8203) {\n                // 8203: ZERO WIDTH SPACE unicode\n                if (_s.backspace === true) this.removeTags();else if (_s.backspace == 'edit') setTimeout(this.editTag.bind(this), 0); // timeout reason: when edited tag gets focused and the caret is placed at the end, the last character gets deletec (because of backspace)\n              }\n            }\n\n            break;\n          case 'Esc':\n          case 'Escape':\n            if (this.state.dropdown.visible) return;\n            e.target.blur();\n            break;\n          case 'Down':\n          case 'ArrowDown':\n            // if( _s.mode == 'select' ) // issue #333\n            if (!this.state.dropdown.visible) this.dropdown.show();\n            break;\n          case 'ArrowRight':\n            {\n              let tagData = this.state.inputSuggestion || this.state.ddItemData;\n              if (tagData && _s.autoComplete.rightKey) {\n                this.addTags([tagData], true);\n                return;\n              }\n              break;\n            }\n          case 'Tab':\n            {\n              let selectMode = _s.mode == 'select';\n              if (s && !selectMode) e.preventDefault();else return true;\n            }\n          case 'Enter':\n            // manual suggestion boxes are assumed to always be visible\n            if (this.state.dropdown.visible && _s.dropdown.position != 'manual') return;\n            e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n            // because the main \"keydown\" event is bound before the dropdown events, this will fire first and will not *yet*\n            // know if an option was just selected from the dropdown menu. If an option was selected,\n            // the dropdown events should handle adding the tag\n            setTimeout(() => {\n              if (this.state.dropdown.visible || this.state.actions.selectOption) return;\n              this.addTags(s, true);\n            });\n        }\n      },\n      onInput(e) {\n        this.postUpdate(); // toggles \"tagify--empty\" class\n\n        var _s = this.settings;\n        if (_s.mode == 'mix') return this.events.callbacks.onMixTagsInput.call(this, e);\n        var value = this.input.normalize.call(this),\n          showSuggestions = value.length >= _s.dropdown.enabled,\n          eventData = {\n            value,\n            inputElm: this.DOM.input\n          },\n          validation = this.validateTag({\n            value\n          });\n        if (_s.mode == 'select') {\n          this.toggleScopeValidation(validation);\n        }\n        eventData.isValid = validation;\n\n        // for IE; since IE doesn't have an \"input\" event so \"keyDown\" is used instead to trigger the \"onInput\" callback,\n        // and so many keys do not change the input, and for those do not continue.\n        if (this.state.inputText == value) return;\n\n        // save the value on the input's State object\n        this.input.set.call(this, value, false); // update the input with the normalized value and run validations\n        // this.setRangeAtStartEnd(false, this.DOM.input); // fix caret position\n\n        // if delimiters detected, add tags\n        if (value.search(_s.delimiters) != -1) {\n          if (this.addTags(value)) {\n            this.input.set.call(this); // clear the input field's value\n          }\n        } else if (_s.dropdown.enabled >= 0) {\n          this.dropdown[showSuggestions ? \"show\" : \"hide\"](value);\n        }\n        this.trigger('input', eventData); // \"input\" event must be triggered at this point, before the dropdown is shown\n      },\n\n      onMixTagsInput(e) {\n        var rangeText,\n          match,\n          matchedPatternCount,\n          tag,\n          showSuggestions,\n          selection,\n          _s = this.settings,\n          lastTagsCount = this.value.length,\n          matchFlaggedTag,\n          matchDelimiters,\n          tagsElems = this.getTagElms(),\n          fragment = document.createDocumentFragment(),\n          range = window.getSelection().getRangeAt(0),\n          remainingTagsValues = [].map.call(tagsElems, node => getSetTagData(node).value);\n\n        // Android Chrome \"keydown\" event argument does not report the correct \"key\".\n        // this workaround is needed to manually call \"onKeydown\" method with a synthesized event object\n        if (e.inputType == \"deleteContentBackward\" && isChromeAndroidBrowser()) {\n          this.events.callbacks.onKeydown.call(this, {\n            target: e.target,\n            key: \"Backspace\"\n          });\n        }\n\n        // re-add \"readonly\" tags which might have been removed\n        this.value.slice().forEach(item => {\n          if (item.readonly && !remainingTagsValues.includes(item.value)) fragment.appendChild(this.createTagElem(item));\n        });\n        if (fragment.childNodes.length) {\n          range.insertNode(fragment);\n          this.setRangeAtStartEnd(false, fragment.lastChild);\n        }\n\n        // check if tags were \"magically\" added/removed (browser redo/undo or CTRL-A -> delete)\n        if (tagsElems.length != lastTagsCount) {\n          this.value = [].map.call(this.getTagElms(), node => getSetTagData(node));\n          this.update({\n            withoutChangeEvent: true\n          });\n          return;\n        }\n        if (this.hasMaxTags()) return true;\n        if (window.getSelection) {\n          selection = window.getSelection();\n\n          // only detect tags if selection is inside a textNode (not somehow on already-existing tag)\n          if (selection.rangeCount > 0 && selection.anchorNode.nodeType == 3) {\n            range = selection.getRangeAt(0).cloneRange();\n            range.collapse(true);\n            range.setStart(selection.focusNode, 0);\n            rangeText = range.toString().slice(0, range.endOffset); // slice the range so everything AFTER the caret will be trimmed\n            // split = range.toString().split(_s.mixTagsAllowedAfter)  // [\"foo\", \"bar\", \"@baz\"]\n            matchedPatternCount = rangeText.split(_s.pattern).length - 1;\n            match = rangeText.match(_s.pattern);\n            if (match)\n              // tag string, example: \"@aaa ccc\"\n              tag = rangeText.slice(rangeText.lastIndexOf(match[match.length - 1]));\n            if (tag) {\n              this.state.actions.ArrowLeft = false; // start fresh, assuming the user did not (yet) used any arrow to move the caret\n              this.state.tag = {\n                prefix: tag.match(_s.pattern)[0],\n                value: tag.replace(_s.pattern, '') // get rid of the prefix\n              };\n\n              this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length;\n              matchDelimiters = this.state.tag.value.match(_s.delimiters);\n              // if a delimeter exists, add the value as tag (exluding the delimiter)\n              if (matchDelimiters) {\n                this.state.tag.value = this.state.tag.value.replace(_s.delimiters, '');\n                this.state.tag.delimiters = matchDelimiters[0];\n                this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect);\n                this.dropdown.hide();\n                return;\n              }\n              showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled;\n\n              // When writeing something that might look like a tag (an email address) but isn't one - it is unwanted\n              // the suggestions dropdown be shown, so the user closes it (in any way), and while continue typing,\n              // dropdown should stay closed until another tag is typed.\n              // if( this.state.tag.value.length && this.state.dropdown.visible === false )\n              //     showSuggestions = false\n\n              // test for similar flagged tags to the current tag\n\n              try {\n                matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset];\n                matchFlaggedTag = matchFlaggedTag.prefix == this.state.tag.prefix && matchFlaggedTag.value[0] == this.state.tag.value[0];\n\n                // reset\n                if (this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value) delete this.state.flaggedTags[this.state.tag.baseOffset];\n              } catch (err) {}\n\n              // scenario: (do not show suggestions of previous matched tag, if more than 1 detected)\n              // (2 tags exist)                          \" a@a.com and @\"\n              // (second tag is removed by backspace)    \" a@a.com and \"\n              if (matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount) showSuggestions = false;\n            }\n            // no (potential) tag found\n            else {\n              this.state.flaggedTags = {};\n            }\n            this.state.mixMode.matchedPatternCount = matchedPatternCount;\n          }\n        }\n\n        // wait until the \"this.value\" has been updated (see \"onKeydown\" method for \"mix-mode\")\n        // the dropdown must be shown only after this event has been triggered, so an implementer could\n        // dynamically change the whitelist.\n        setTimeout(() => {\n          this.update({\n            withoutChangeEvent: true\n          });\n          this.trigger(\"input\", extend({}, this.state.tag, {\n            textContent: this.DOM.input.textContent\n          }));\n          if (this.state.tag) this.dropdown[showSuggestions ? \"show\" : \"hide\"](this.state.tag.value);\n        }, 10);\n      },\n      onInputIE(e) {\n        var _this = this;\n        // for the \"e.target.textContent\" to be changed, the browser requires a small delay\n        setTimeout(function () {\n          _this.events.callbacks.onInput.call(_this, e);\n        });\n      },\n      observeOriginalInputValue() {\n        // if, for some reason, the Tagified element is no longer in the DOM,\n        // call the \"destroy\" method to kill all references to timeouts/intervals\n        if (!this.DOM.originalInput.parentNode) this.destroy();\n\n        // if original input value changed for some reason (for exmaple a form reset)\n        if (this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue) this.loadOriginalValues();\n      },\n      onClickScope(e) {\n        var _s = this.settings,\n          tagElm = e.target.closest('.' + _s.classNames.tag),\n          timeDiffFocus = +new Date() - this.state.hasFocus;\n        if (e.target == this.DOM.scope) {\n          if (!this.state.hasFocus) this.DOM.input.focus();\n          return;\n        } else if (e.target.classList.contains(_s.classNames.tagX)) {\n          this.removeTags(e.target.parentNode);\n          return;\n        } else if (tagElm) {\n          this.trigger(\"click\", {\n            tag: tagElm,\n            index: this.getNodeIndex(tagElm),\n            data: getSetTagData(tagElm),\n            event: e\n          });\n          if (_s.editTags === 1 || _s.editTags.clicks === 1) this.events.callbacks.onDoubleClickScope.call(this, e);\n          return;\n        }\n\n        // when clicking on the input itself\n        else if (e.target == this.DOM.input) {\n          if (_s.mode == 'mix') {\n            // firefox won't show caret if last element is a tag (and not a textNode),\n            // so an empty textnode should be added\n            this.fixFirefoxLastTagNoCaret();\n          }\n          if (timeDiffFocus > 500) {\n            if (this.state.dropdown.visible) this.dropdown.hide();else if (_s.dropdown.enabled === 0 && _s.mode != 'mix') this.dropdown.show(this.value.length ? '' : undefined);\n            return;\n          }\n        }\n        if (_s.mode == 'select' && _s.dropdown.enabled === 0 && !this.state.dropdown.visible) this.dropdown.show();\n      },\n      // special proccess is needed for pasted content in order to \"clean\" it\n      onPaste(e) {\n        e.preventDefault();\n        var _s = this.settings,\n          selectModeWithoutInput = _s.mode == 'select' && _s.enforceWhitelist;\n        if (selectModeWithoutInput || !_s.userInput) {\n          return false;\n        }\n        var clipboardData, pastedText;\n        if (_s.readonly) return;\n\n        // Get pasted data via clipboard API\n        clipboardData = e.clipboardData || window.clipboardData;\n        pastedText = clipboardData.getData('Text');\n        _s.hooks.beforePaste(e, {\n          tagify: this,\n          pastedText,\n          clipboardData\n        }).then(result => {\n          if (result === undefined) result = pastedText;\n          if (result) {\n            this.injectAtCaret(result, window.getSelection().getRangeAt(0));\n            if (this.settings.mode == 'mix') {\n              this.events.callbacks.onMixTagsInput.call(this, e);\n            } else if (this.settings.pasteAsTags) {\n              this.addTags(this.state.inputText + result, true);\n            } else this.state.inputText = result;\n          }\n        }).catch(err => err);\n      },\n      onDrop(e) {\n        e.preventDefault();\n      },\n      onEditTagInput(editableElm, e) {\n        var tagElm = editableElm.closest('.' + this.settings.classNames.tag),\n          tagElmIdx = this.getNodeIndex(tagElm),\n          tagData = getSetTagData(tagElm),\n          textValue = this.input.normalize.call(this, editableElm),\n          dataForChangedProp = {\n            [this.settings.tagTextProp]: textValue,\n            __tagId: tagData.__tagId\n          },\n          // \"__tagId\" is needed so validation will skip current tag when checking for dups\n          isValid = this.validateTag(dataForChangedProp),\n          // the value could have been invalid in the first-place so make sure to re-validate it (via \"addEmptyTag\" method)\n          hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp));\n\n        // if the value is same as before-editing and the tag was valid before as well, ignore the  current \"isValid\" result, which is false-positive\n        if (!hasChanged && editableElm.originalIsValid === true) isValid = true;\n        tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true);\n        tagData.__isValid = isValid;\n        tagElm.title = isValid === true ? tagData.title || tagData.value : isValid; // change the tag's title to indicate why is the tag invalid (if it's so)\n\n        // show dropdown if typed text is equal or more than the \"enabled\" dropdown setting\n        if (textValue.length >= this.settings.dropdown.enabled) {\n          // this check is needed apparently because doing browser \"undo\" will fire\n          //  \"onEditTagInput\" but \"this.state.editing\" will be \"false\"\n          if (this.state.editing) this.state.editing.value = textValue;\n          this.dropdown.show(textValue);\n        }\n        this.trigger(\"edit:input\", {\n          tag: tagElm,\n          index: tagElmIdx,\n          data: extend({}, this.value[tagElmIdx], {\n            newValue: textValue\n          }),\n          event: e\n        });\n      },\n      onEditTagPaste(tagElm, e) {\n        // Get pasted data via clipboard API\n        var clipboardData = e.clipboardData || window.clipboardData,\n          pastedText = clipboardData.getData('Text');\n        e.preventDefault();\n        var newNode = injectAtCaret(pastedText);\n        this.setRangeAtStartEnd(false, newNode);\n      },\n      onEditTagFocus(tagElm) {\n        this.state.editing = {\n          scope: tagElm,\n          input: tagElm.querySelector(\"[contenteditable]\")\n        };\n      },\n      onEditTagBlur(editableElm) {\n        if (!this.state.hasFocus) this.toggleFocusClass();\n\n        // one scenario is when selecting a suggestion from the dropdown, when editing, and by selecting it\n        // the \"onEditTagDone\" is called directly, already replacing the tag, so the argument \"editableElm\"\n        // node isn't in the DOM anynmore because it has been replaced.\n        if (!this.DOM.scope.contains(editableElm)) return;\n        var _s = this.settings,\n          tagElm = editableElm.closest('.' + _s.classNames.tag),\n          textValue = this.input.normalize.call(this, editableElm),\n          tagData = getSetTagData(tagElm),\n          originalData = tagData.__originalData,\n          // pre-edit data\n          hasChanged = this.editTagChangeDetected(tagData),\n          isValid = this.validateTag({\n            [_s.tagTextProp]: textValue,\n            __tagId: tagData.__tagId\n          }),\n          // \"__tagId\" is needed so validation will skip current tag when checking for dups\n          hasMaxTags,\n          newTagData;\n        if (!textValue) {\n          this.onEditTagDone(tagElm);\n          return;\n        }\n\n        // if nothing changed revert back to how it was before editing\n        if (!hasChanged) {\n          this.onEditTagDone(tagElm, originalData);\n          return;\n        }\n\n        // need to know this because if \"keepInvalidTags\" setting is \"true\" and an invalid tag is edited as a valid one,\n        // but the maximum number of tags have alreay been reached, so it should not allow saving the new valid value.\n        // only if the tag was already valid before editing, ignore this check (see a few lines below)\n        hasMaxTags = this.hasMaxTags();\n        newTagData = extend({}, originalData, {\n          [_s.tagTextProp]: this.trim(textValue),\n          __isValid: isValid\n        });\n\n        // pass through optional transformer defined in settings\n        _s.transformTag.call(this, newTagData, originalData);\n\n        // MUST re-validate after tag transformation\n        // only validate the \"tagTextProp\" because is the only thing that metters for validating an edited tag.\n        // -- Scenarios: --\n        // 1. max 3 tags allowd. there are 4 tags, one has invalid input and is edited to a valid one, and now should be marked as \"not allowed\" because limit of tags has reached\n        // 2. max 3 tags allowed. there are 3 tags, one is edited, and so max-tags vaildation should be OK\n        isValid = (!hasMaxTags || originalData.__isValid === true) && this.validateTag(newTagData);\n        if (isValid !== true) {\n          this.trigger(\"invalid\", {\n            data: newTagData,\n            tag: tagElm,\n            message: isValid\n          });\n\n          // do nothing if invalid, stay in edit-mode until corrected or reverted by presssing esc\n          if (_s.editTags.keepInvalid) return;\n          if (_s.keepInvalidTags) newTagData.__isValid = isValid;else\n            // revert back if not specified to keep\n            newTagData = originalData;\n        } else if (_s.keepInvalidTags) {\n          // cleaup any previous leftovers if the tag was invalid\n          delete newTagData.title;\n          delete newTagData[\"aria-invalid\"];\n          delete newTagData.class;\n        }\n\n        // tagElm.classList.toggle(_s.classNames.tagInvalid, true)\n\n        this.onEditTagDone(tagElm, newTagData);\n      },\n      onEditTagkeydown(e, tagElm) {\n        // ignore keys during IME composition\n        if (this.state.composing) return;\n        this.trigger(\"edit:keydown\", {\n          event: e\n        });\n        switch (e.key) {\n          case 'Esc':\n          case 'Escape':\n            {\n              // revert the tag to how it was before editing\n              // replace current tag with original one (pre-edited one)\n              tagElm.parentNode.replaceChild(tagElm.__tagifyTagData.__originalHTML, tagElm);\n              this.state.editing = false;\n            }\n          case 'Enter':\n          case 'Tab':\n            e.preventDefault();\n            e.target.blur();\n        }\n      },\n      onDoubleClickScope(e) {\n        var tagElm = e.target.closest('.' + this.settings.classNames.tag),\n          tagData = getSetTagData(tagElm),\n          _s = this.settings,\n          isEditingTag,\n          isReadyOnlyTag;\n        if (!tagElm || !_s.userInput || tagData.editable === false) return;\n        isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing);\n        isReadyOnlyTag = tagElm.hasAttribute('readonly');\n        if (_s.mode != 'select' && !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags) this.editTag(tagElm);\n        this.toggleFocusClass(true);\n        this.trigger('dblclick', {\n          tag: tagElm,\n          index: this.getNodeIndex(tagElm),\n          data: getSetTagData(tagElm)\n        });\n      },\n      /**\r\n       *\r\n       * @param {Object} m an object representing the observed DOM changes\r\n       */\n      onInputDOMChange(m) {\n        // iterate all DOm mutation\n        m.forEach(record => {\n          // only the ADDED nodes\n          record.addedNodes.forEach(addedNode => {\n            // fix chrome's placing '<div><br></div>' everytime ENTER key is pressed, and replace with just `<br'\n            if (addedNode.outerHTML == '<div><br></div>') {\n              addedNode.replaceWith(document.createElement('br'));\n            }\n\n            // if the added element is a div containing a tag within it (chrome does this when pressing ENTER before a tag)\n            else if (addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector)) {\n              let newlineText = document.createTextNode('');\n              if (addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != 'BR') newlineText = document.createTextNode('\\n');\n\n              // unwrap the useless div\n              // chrome adds a BR at the end which should be removed\n              addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0, -1)]);\n              this.placeCaretAfterNode(newlineText);\n            }\n\n            // if this is a tag\n            else if (isNodeTag.call(this, addedNode)) {\n              if (addedNode.previousSibling?.nodeType == 3 && !addedNode.previousSibling.textContent) addedNode.previousSibling.remove();\n              // and it is the first node in a new line\n              if (addedNode.previousSibling && addedNode.previousSibling.nodeName == 'BR') {\n                // allows placing the caret just before the tag, when the tag is the first node in that line\n                addedNode.previousSibling.replaceWith('\\n\\u200B');\n                let nextNode = addedNode.nextSibling,\n                  anythingAfterNode = '';\n                while (nextNode) {\n                  anythingAfterNode += nextNode.textContent;\n                  nextNode = nextNode.nextSibling;\n                }\n\n                // when hitting ENTER for new line just before an existing tag, but skip below logic when a tag has been addded\n                anythingAfterNode.trim() && this.placeCaretAfterNode(addedNode.previousSibling);\n              }\n            }\n          });\n          record.removedNodes.forEach(removedNode => {\n            // when trying to delete a tag which is in a new line and there's nothing else there (caret is after the tag)\n            if (removedNode && removedNode.nodeName == 'BR' && isNodeTag.call(this, lastInputChild)) {\n              this.removeTags(lastInputChild);\n              this.fixFirefoxLastTagNoCaret();\n            }\n          });\n        });\n\n        // get the last child only after the above DOM modifications\n        // check these scenarios:\n        // 1. after a single line, press ENTER once - should add only 1 BR\n        // 2. presss ENTER right before a tag\n        // 3. press enter within a text node before a tag\n        var lastInputChild = this.DOM.input.lastChild;\n        if (lastInputChild && lastInputChild.nodeValue == '') lastInputChild.remove();\n\n        // make sure the last element is always a BR\n        if (!lastInputChild || lastInputChild.nodeName != 'BR') {\n          this.DOM.input.appendChild(document.createElement('br'));\n        }\n      }\n    }\n  };\n\n  /**\r\n   * @constructor\r\n   * @param {Object} input    DOM element\r\n   * @param {Object} settings settings object\r\n   */\n  function Tagify(input, settings) {\n    if (!input) {\n      console.warn('Tagify:', 'input element not found', input);\n      // return an empty mock of all methods, so the code using tagify will not break\n      // because it might be calling methods even though the input element does not exist\n      const mockInstance = new Proxy(this, {\n        get() {\n          return () => mockInstance;\n        }\n      });\n      return mockInstance;\n    }\n    if (input.__tagify) {\n      console.warn('Tagify: ', 'input element is already Tagified - Same instance is returned.', input);\n      return input.__tagify;\n    }\n    extend(this, EventDispatcher(this));\n    this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent);\n    this.isIE = window.document.documentMode; // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode#Browser_compatibility\n\n    settings = settings || {};\n    this.getPersistedData = getPersistedData(settings.id);\n    this.setPersistedData = setPersistedData(settings.id);\n    this.clearPersistedData = clearPersistedData(settings.id);\n    this.applySettings(input, settings);\n    this.state = {\n      inputText: '',\n      editing: false,\n      composing: false,\n      actions: {},\n      // UI actions for state-locking\n      mixMode: {},\n      dropdown: {},\n      flaggedTags: {} // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here\n    };\n\n    this.value = []; // tags' data\n\n    // events' callbacks references will be stores here, so events could be unbinded\n    this.listeners = {};\n    this.DOM = {}; // Store all relevant DOM elements in an Object\n\n    this.build(input);\n    initDropdown.call(this);\n    this.getCSSVars();\n    this.loadOriginalValues();\n    this.events.customBinding.call(this);\n    this.events.binding.call(this);\n    input.autofocus && this.DOM.input.focus();\n    input.__tagify = this;\n  }\n  Tagify.prototype = {\n    _dropdown,\n    helpers: {\n      sameStr,\n      removeCollectionProp,\n      omit,\n      isObject,\n      parseHTML,\n      escapeHTML,\n      extend,\n      concatWithoutDups,\n      getUID,\n      isNodeTag\n    },\n    customEventsList: ['change', 'add', 'remove', 'invalid', 'input', 'click', 'keydown', 'focus', 'blur', 'edit:input', 'edit:beforeUpdate', 'edit:updated', 'edit:start', 'edit:keydown', 'dropdown:show', 'dropdown:hide', 'dropdown:select', 'dropdown:updated', 'dropdown:noMatch', 'dropdown:scroll'],\n    dataProps: ['__isValid', '__removed', '__originalData', '__originalHTML', '__tagId'],\n    // internal-uasge props\n\n    trim(text) {\n      return this.settings.trim && text && typeof text == \"string\" ? text.trim() : text;\n    },\n    // expose this handy utility function\n    parseHTML,\n    templates,\n    parseTemplate(template, data) {\n      template = this.settings.templates[template] || template;\n      return parseHTML(template.apply(this, data));\n    },\n    set whitelist(arr) {\n      const isArray = arr && Array.isArray(arr);\n      this.settings.whitelist = isArray ? arr : [];\n      this.setPersistedData(isArray ? arr : [], 'whitelist');\n    },\n    get whitelist() {\n      return this.settings.whitelist;\n    },\n    generateClassSelectors(classNames) {\n      for (let name in classNames) {\n        let currentName = name;\n        Object.defineProperty(classNames, currentName + \"Selector\", {\n          get() {\n            return \".\" + this[currentName].split(\" \")[0];\n          }\n        });\n      }\n    },\n    applySettings(input, settings) {\n      DEFAULTS.templates = this.templates;\n      var mixModeDefaults = {\n        dropdown: {\n          position: \"text\"\n        }\n      };\n      var mergedDefaults = extend({}, DEFAULTS, settings.mode == 'mix' ? mixModeDefaults : {});\n      var _s = this.settings = extend({}, mergedDefaults, settings);\n      _s.disabled = input.hasAttribute('disabled');\n      _s.readonly = _s.readonly || input.hasAttribute('readonly');\n      _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\");\n      _s.required = input.hasAttribute('required');\n      this.generateClassSelectors(_s.classNames);\n      if (_s.dropdown.includeSelectedTags === undefined) _s.dropdown.includeSelectedTags = _s.duplicates;\n      if (this.isIE) _s.autoComplete = false; // IE goes crazy if this isn't false\n\n      [\"whitelist\", \"blacklist\"].forEach(name => {\n        var attrVal = input.getAttribute('data-' + name);\n        if (attrVal) {\n          attrVal = attrVal.split(_s.delimiters);\n          if (attrVal instanceof Array) _s[name] = attrVal;\n        }\n      });\n\n      // backward-compatibility for old version of \"autoComplete\" setting:\n      if (\"autoComplete\" in settings && !isObject(settings.autoComplete)) {\n        _s.autoComplete = DEFAULTS.autoComplete;\n        _s.autoComplete.enabled = settings.autoComplete;\n      }\n      if (_s.mode == 'mix') {\n        _s.pattern = _s.pattern || /@/;\n        _s.autoComplete.rightKey = true;\n        _s.delimiters = settings.delimiters || null; // default dlimiters in mix-mode must be NULL\n\n        // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n        // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n        // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n        if (_s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp)) _s.dropdown.searchKeys.push(_s.tagTextProp);\n      }\n      if (input.pattern) try {\n        _s.pattern = new RegExp(input.pattern);\n      } catch (e) {}\n\n      // Convert the \"delimiters\" setting into a REGEX object\n      if (_s.delimiters) {\n        _s._delimiters = _s.delimiters;\n        try {\n          _s.delimiters = new RegExp(this.settings.delimiters, \"g\");\n        } catch (e) {}\n      }\n      if (_s.disabled) _s.userInput = false;\n      this.TEXTS = _objectSpread2(_objectSpread2({}, TEXTS), _s.texts || {});\n\n      // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\n      if (_s.mode == 'select' && !settings.dropdown?.enabled || !_s.userInput) {\n        _s.dropdown.enabled = 0;\n      }\n      _s.dropdown.appendTarget = settings.dropdown?.appendTarget || document.body;\n\n      // get & merge persisted data with current data\n      let persistedWhitelist = this.getPersistedData('whitelist');\n      if (Array.isArray(persistedWhitelist)) this.whitelist = Array.isArray(_s.whitelist) ? concatWithoutDups(_s.whitelist, persistedWhitelist) : persistedWhitelist;\n    },\n    /**\r\n     * Returns a string of HTML element attributes\r\n     * @param {Object} data [Tag data]\r\n     */\n    getAttributes(data) {\n      var attrs = this.getCustomAttributes(data),\n        s = '',\n        k;\n      for (k in attrs) s += \" \" + k + (data[k] !== undefined ? `=\"${attrs[k]}\"` : \"\");\n      return s;\n    },\n    /**\r\n     * Returns an object of attributes to be used for the templates\r\n     */\n    getCustomAttributes(data) {\n      // only items which are objects have properties which can be used as attributes\n      if (!isObject(data)) return '';\n      var output = {},\n        propName;\n      for (propName in data) {\n        if (propName.slice(0, 2) != '__' && propName != 'class' && data.hasOwnProperty(propName) && data[propName] !== undefined) output[propName] = escapeHTML(data[propName]);\n      }\n      return output;\n    },\n    setStateSelection() {\n      var selection = window.getSelection();\n\n      // save last selection place to be able to inject anything from outside to that specific place\n      var sel = {\n        anchorOffset: selection.anchorOffset,\n        anchorNode: selection.anchorNode,\n        range: selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)\n      };\n      this.state.selection = sel;\n      return sel;\n    },\n    /**\r\n     * Get specific CSS variables which are relevant to this script and parse them as needed.\r\n     * The result is saved on the instance in \"this.CSSVars\"\r\n     */\n    getCSSVars() {\n      var compStyle = getComputedStyle(this.DOM.scope, null);\n      const getProp = name => compStyle.getPropertyValue('--' + name);\n      function seprateUnitFromValue(a) {\n        if (!a) return {};\n        a = a.trim().split(' ')[0];\n        var unit = a.split(/\\d+/g).filter(n => n).pop().trim(),\n          value = +a.split(unit).filter(n => n)[0].trim();\n        return {\n          value,\n          unit\n        };\n      }\n      this.CSSVars = {\n        tagHideTransition: (_ref => {\n          let value = _ref.value,\n            unit = _ref.unit;\n          return unit == 's' ? value * 1000 : value;\n        })(seprateUnitFromValue(getProp('tag-hide-transition')))\n      };\n    },\n    /**\r\n     * builds the HTML of this component\r\n     * @param  {Object} input [DOM element which would be \"transformed\" into \"Tags\"]\r\n     */\n    build(input) {\n      var DOM = this.DOM;\n      if (this.settings.mixMode.integrated) {\n        DOM.originalInput = null;\n        DOM.scope = input;\n        DOM.input = input;\n      } else {\n        DOM.originalInput = input;\n        DOM.originalInput_tabIndex = input.tabIndex;\n        DOM.scope = this.parseTemplate('wrapper', [input, this.settings]);\n        DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector);\n        input.parentNode.insertBefore(DOM.scope, input);\n        input.tabIndex = -1; // do not allow focus or typing directly, once tagified\n      }\n    },\n\n    /**\r\n     * revert any changes made by this component\r\n     */\n    destroy() {\n      this.events.unbindGlobal.call(this);\n      this.DOM.scope.parentNode.removeChild(this.DOM.scope);\n      this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex;\n      delete this.DOM.originalInput.__tagify;\n      this.dropdown.hide(true);\n      clearTimeout(this.dropdownHide__bindEventsTimeout);\n      clearInterval(this.listeners.main.originalInputValueObserverInterval);\n    },\n    /**\r\n     * if the original input has any values, add them as tags\r\n     */\n    loadOriginalValues(value) {\n      var lastChild,\n        _s = this.settings;\n\n      // temporarily block firign the \"change\" event on the original input unil\n      // this method finish removing current value and adding the new one\n      this.state.blockChangeEvent = true;\n      if (value === undefined) {\n        const persistedOriginalValue = this.getPersistedData('value');\n\n        // if the field already has a field, trust its the desired\n        // one to be rendered and do not use the persisted one\n        if (persistedOriginalValue && !this.DOM.originalInput.value) value = persistedOriginalValue;else value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;\n      }\n      this.removeAllTags();\n      if (value) {\n        if (_s.mode == 'mix') {\n          this.parseMixTags(value);\n          lastChild = this.DOM.input.lastChild;\n\n          // fixes a Chrome bug, when the last node in `mix-mode` is a tag, the caret appears at the far-top-top, outside the field\n          if (!lastChild || lastChild.tagName != 'BR') this.DOM.input.insertAdjacentHTML('beforeend', '<br>');\n        } else {\n          try {\n            if (JSON.parse(value) instanceof Array) value = JSON.parse(value);\n          } catch (err) {}\n          this.addTags(value, true).forEach(tag => tag && tag.classList.add(_s.classNames.tagNoAnimation));\n        }\n      } else this.postUpdate();\n      this.state.lastOriginalValueReported = _s.mixMode.integrated ? '' : this.DOM.originalInput.value;\n      this.state.blockChangeEvent = false;\n    },\n    cloneEvent(e) {\n      var clonedEvent = {};\n      for (var v in e) if (v != 'path') clonedEvent[v] = e[v];\n      return clonedEvent;\n    },\n    /**\r\n     * Toogle global loading state on/off\r\n     * Useful when fetching async whitelist while user is typing\r\n     * @param {Boolean} isLoading\r\n     */\n    loading(isLoading) {\n      this.state.isLoading = isLoading;\n      // IE11 doesn't support toggle with second parameter\n      this.DOM.scope.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.scopeLoading);\n      return this;\n    },\n    /**\r\n     * Toogle a tag loading state on/off\r\n     * @param {Boolean} isLoading\r\n     */\n    tagLoading(tagElm, isLoading) {\n      if (tagElm)\n        // IE11 doesn't support toggle with second parameter\n        tagElm.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.tagLoading);\n      return this;\n    },\n    /**\r\n     * Toggles class on the main tagify container (\"scope\")\r\n     * @param {String} className\r\n     * @param {Boolean} force\r\n     */\n    toggleClass(className, force) {\n      if (typeof className == 'string') this.DOM.scope.classList.toggle(className, force);\n    },\n    toggleScopeValidation(validation) {\n      var isValid = validation === true || validation === undefined; // initially it is undefined\n\n      if (!this.settings.required && validation && validation === this.TEXTS.empty) isValid = true;\n      this.toggleClass(this.settings.classNames.tagInvalid, !isValid);\n      this.DOM.scope.title = isValid ? '' : validation;\n    },\n    toggleFocusClass(force) {\n      this.toggleClass(this.settings.classNames.focus, !!force);\n    },\n    triggerChangeEvent,\n    events,\n    fixFirefoxLastTagNoCaret() {\n      return; // seems to be fixed in newer version of FF, so retiring below code (for now)\n      // var inputElm = this.DOM.input\n\n      // if( this.isFirefox && inputElm.childNodes.length && inputElm.lastChild.nodeType == 1 ){\n      //     inputElm.appendChild(document.createTextNode(\"\\u200b\"))\n      //     this.setRangeAtStartEnd(true, inputElm)\n      //     return true\n      // }\n    },\n\n    /** https://stackoverflow.com/a/59156872/104380\r\n     * @param {Boolean} start indicating where to place it (start or end of the node)\r\n     * @param {Object}  node  DOM node to place the caret at\r\n     */\n    setRangeAtStartEnd(start, node) {\n      if (!node) return;\n      start = typeof start == 'number' ? start : !!start;\n      node = node.lastChild || node;\n      var sel = document.getSelection();\n\n      // do not force caret placement if the current selection (focus) is on another element (not this tagify instance)\n      if (sel.focusNode instanceof Element && !this.DOM.input.contains(sel.focusNode)) {\n        return true;\n      }\n      try {\n        if (sel.rangeCount >= 1) {\n          ['Start', 'End'].forEach(pos => sel.getRangeAt(0)[\"set\" + pos](node, start ? start : node.length));\n        }\n      } catch (err) {\n        // console.warn(\"Tagify: \", err)\n      }\n    },\n    placeCaretAfterNode(node) {\n      if (!node || !node.parentNode) return;\n      var nextSibling = node,\n        sel = window.getSelection(),\n        range = sel.getRangeAt(0);\n      if (sel.rangeCount) {\n        range.setStartAfter(nextSibling);\n        range.collapse(true);\n        // range.setEndBefore(nextSibling || node);\n        sel.removeAllRanges();\n        sel.addRange(range);\n      }\n    },\n    insertAfterTag(tagElm, newNode) {\n      newNode = newNode || this.settings.mixMode.insertAfterTag;\n      if (!tagElm || !tagElm.parentNode || !newNode) return;\n      newNode = typeof newNode == 'string' ? document.createTextNode(newNode) : newNode;\n      tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling);\n      return newNode;\n    },\n    // compares all \"__originalData\" property values with the current \"tagData\" properties\n    // and returns \"true\" if something changed.\n    editTagChangeDetected(tagData) {\n      var originalData = tagData.__originalData;\n      for (var prop in originalData) if (!this.dataProps.includes(prop) && tagData[prop] != originalData[prop]) return true;\n      return false; // not changed\n    },\n\n    // returns the node which has the actual tag's content\n    getTagTextNode(tagElm) {\n      return tagElm.querySelector(this.settings.classNames.tagTextSelector);\n    },\n    // sets the text of a tag\n    setTagTextNode(tagElm, HTML) {\n      this.getTagTextNode(tagElm).innerHTML = escapeHTML(HTML);\n    },\n    /**\r\n     * Enters a tag into \"edit\" mode\r\n     * @param {Node} tagElm the tag element to edit. if nothing specified, use last last\r\n     */\n    editTag(tagElm, opts) {\n      tagElm = tagElm || this.getLastTag();\n      opts = opts || {};\n      this.dropdown.hide();\n      var _s = this.settings,\n        editableElm = this.getTagTextNode(tagElm),\n        tagIdx = this.getNodeIndex(tagElm),\n        tagData = getSetTagData(tagElm),\n        _CB = this.events.callbacks,\n        that = this,\n        isValid = true,\n        delayed_onEditTagBlur = function () {\n          setTimeout(() => _CB.onEditTagBlur.call(that, that.getTagTextNode(tagElm)));\n        };\n      if (!editableElm) {\n        console.warn('Cannot find element in Tag template: .', _s.classNames.tagTextSelector);\n        return;\n      }\n      if (tagData instanceof Object && \"editable\" in tagData && !tagData.editable) return;\n\n      // cache the original data, on the DOM node, before any modification ocurs, for possible revert\n      tagData = getSetTagData(tagElm, {\n        __originalData: extend({}, tagData),\n        __originalHTML: tagElm.cloneNode(true)\n      });\n      // re-set the tagify custom-prop on the clones element (because cloning removed it)\n      getSetTagData(tagData.__originalHTML, tagData.__originalData);\n      editableElm.setAttribute('contenteditable', true);\n      tagElm.classList.add(_s.classNames.tagEditing);\n      editableElm.addEventListener('focus', _CB.onEditTagFocus.bind(this, tagElm));\n      editableElm.addEventListener('blur', delayed_onEditTagBlur);\n      editableElm.addEventListener('input', _CB.onEditTagInput.bind(this, editableElm));\n      editableElm.addEventListener('paste', _CB.onEditTagPaste.bind(this, editableElm));\n      editableElm.addEventListener('keydown', e => _CB.onEditTagkeydown.call(this, e, tagElm));\n      editableElm.addEventListener('compositionstart', _CB.onCompositionStart.bind(this));\n      editableElm.addEventListener('compositionend', _CB.onCompositionEnd.bind(this));\n      if (!opts.skipValidation) isValid = this.editTagToggleValidity(tagElm);\n      editableElm.originalIsValid = isValid;\n      this.trigger(\"edit:start\", {\n        tag: tagElm,\n        index: tagIdx,\n        data: tagData,\n        isValid\n      });\n      editableElm.focus();\n      this.setRangeAtStartEnd(false, editableElm); // place the caret at the END of the editable tag text\n\n      return this;\n    },\n    /**\r\n     * If a tag is invalid, for any reason, set its class to \"not allowed\" (see defaults file)\r\n     * @param {Node} tagElm required\r\n     * @param {Object} tagData optional\r\n     * @returns true if valid, a string (reason) if not\r\n     */\n    editTagToggleValidity(tagElm, tagData) {\n      var tagData = tagData || getSetTagData(tagElm),\n        isValid;\n      if (!tagData) {\n        console.warn(\"tag has no data: \", tagElm, tagData);\n        return;\n      }\n      isValid = !(\"__isValid\" in tagData) || tagData.__isValid === true;\n      if (!isValid) {\n        this.removeTagsFromValue(tagElm);\n      }\n      this.update();\n\n      //this.validateTag(tagData);\n\n      tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid);\n      return tagData.__isValid;\n    },\n    onEditTagDone(tagElm, tagData) {\n      tagElm = tagElm || this.state.editing.scope;\n      tagData = tagData || {};\n      var eventData = {\n        tag: tagElm,\n        index: this.getNodeIndex(tagElm),\n        previousData: getSetTagData(tagElm),\n        data: tagData\n      };\n      this.trigger(\"edit:beforeUpdate\", eventData, {\n        cloneData: false\n      });\n      this.state.editing = false;\n      delete tagData.__originalData;\n      delete tagData.__originalHTML;\n      if (tagElm && tagData[this.settings.tagTextProp]) {\n        tagElm = this.replaceTag(tagElm, tagData);\n        this.editTagToggleValidity(tagElm, tagData);\n        if (this.settings.a11y.focusableTags) tagElm.focus();else\n          // place caret after edited tag\n          this.placeCaretAfterNode(tagElm);\n      } else if (tagElm) this.removeTags(tagElm);\n      this.trigger(\"edit:updated\", eventData);\n      this.dropdown.hide();\n\n      // check if any of the current tags which might have been marked as \"duplicate\" should be now un-marked\n      if (this.settings.keepInvalidTags) this.reCheckInvalidTags();\n    },\n    /**\r\n     * Replaces an exisitng tag with a new one. Used for updating a tag's data\r\n     * @param {Object} tagElm  [DOM node to replace]\r\n     * @param {Object} tagData [data to create new tag from]\r\n     */\n    replaceTag(tagElm, tagData) {\n      if (!tagData || !tagData.value) tagData = tagElm.__tagifyTagData;\n\n      // if tag is invalid, make the according changes in the newly created element\n      if (tagData.__isValid && tagData.__isValid != true) extend(tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid));\n      var newTagElm = this.createTagElem(tagData);\n\n      // update DOM\n      tagElm.parentNode.replaceChild(newTagElm, tagElm);\n      this.updateValueByDOMTags();\n      return newTagElm;\n    },\n    /**\r\n     * update \"value\" (Array of Objects) by traversing all valid tags\r\n     */\n    updateValueByDOMTags() {\n      this.value.length = 0;\n      [].forEach.call(this.getTagElms(), node => {\n        if (node.classList.contains(this.settings.classNames.tagNotAllowed.split(' ')[0])) return;\n        this.value.push(getSetTagData(node));\n      });\n      this.update();\n    },\n    /**\r\n     * injects nodes/text at caret position, which is saved on the \"state\" when \"blur\" event gets triggered\r\n     * @param {Node} injectedNode [the node to inject at the caret position]\r\n     * @param {Object} selection [optional range Object. must have \"anchorNode\" & \"anchorOffset\"]\r\n     */\n    injectAtCaret(injectedNode, range) {\n      range = range || this.state.selection?.range;\n      if (!range && injectedNode) {\n        this.appendMixTags(injectedNode);\n        return this;\n      }\n      injectAtCaret(injectedNode, range);\n      this.setRangeAtStartEnd(false, injectedNode);\n      this.updateValueByDOMTags(); // updates internal \"this.value\"\n      this.update(); // updates original input/textarea\n\n      return this;\n    },\n    /**\r\n     * input bridge for accessing & setting\r\n     * @type {Object}\r\n     */\n    input: {\n      set() {\n        let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        let updateDOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var hideDropdown = this.settings.dropdown.closeOnSelect;\n        this.state.inputText = s;\n        if (updateDOM) this.DOM.input.innerHTML = escapeHTML(\"\" + s);\n        if (!s && hideDropdown) this.dropdown.hide.bind(this);\n        this.input.autocomplete.suggest.call(this);\n        this.input.validate.call(this);\n      },\n      raw() {\n        return this.DOM.input.textContent;\n      },\n      /**\r\n       * Marks the tagify's input as \"invalid\" if the value did not pass \"validateTag()\"\r\n       */\n      validate() {\n        var isValid = !this.state.inputText || this.validateTag({\n          value: this.state.inputText\n        }) === true;\n        this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid);\n        return isValid;\n      },\n      // remove any child DOM elements that aren't of type TEXT (like <br>)\n      normalize(node) {\n        var clone = node || this.DOM.input,\n          //.cloneNode(true),\n          v = [];\n\n        // when a text was pasted in FF, the \"this.DOM.input\" element will have <br> but no newline symbols (\\n), and this will\n        // result in tags not being properly created if one wishes to create a separate tag per newline.\n        clone.childNodes.forEach(n => n.nodeType == 3 && v.push(n.nodeValue));\n        v = v.join(\"\\n\");\n        try {\n          // \"delimiters\" might be of a non-regex value, where this will fail (\"Tags With Properties\" example in demo page):\n          v = v.replace(/(?:\\r\\n|\\r|\\n)/g, this.settings.delimiters.source.charAt(0));\n        } catch (err) {}\n        v = v.replace(/\\s/g, ' '); // replace NBSPs with spaces characters\n\n        return this.trim(v);\n      },\n      /**\r\n       * suggest the rest of the input's value (via CSS \"::after\" using \"content:attr(...)\")\r\n       * @param  {String} s [description]\r\n       */\n      autocomplete: {\n        suggest(data) {\n          if (!this.settings.autoComplete.enabled) return;\n          data = data || {\n            value: ''\n          };\n          if (typeof data == 'string') data = {\n            value: data\n          };\n          var suggestedText = this.dropdown.getMappedValue(data);\n          if (typeof suggestedText === 'number') return;\n          var suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(),\n            suggestionTrimmed = suggestedText.substring(this.state.inputText.length);\n          if (!suggestedText || !this.state.inputText || suggestionStart != this.state.inputText.toLowerCase()) {\n            this.DOM.input.removeAttribute(\"data-suggest\");\n            delete this.state.inputSuggestion;\n          } else {\n            this.DOM.input.setAttribute(\"data-suggest\", suggestionTrimmed);\n            this.state.inputSuggestion = data;\n          }\n        },\n        /**\r\n         * sets the suggested text as the input's value & cleanup the suggestion autocomplete.\r\n         * @param {String} s [text]\r\n         */\n        set(s) {\n          var dataSuggest = this.DOM.input.getAttribute('data-suggest'),\n            suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);\n          if (suggestion) {\n            if (this.settings.mode == 'mix') {\n              this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + suggestion));\n            } else {\n              this.input.set.call(this, suggestion);\n              this.setRangeAtStartEnd(false, this.DOM.input);\n            }\n            this.input.autocomplete.suggest.call(this);\n            this.dropdown.hide();\n            return true;\n          }\n          return false;\n        }\n      }\n    },\n    /**\r\n     * returns the index of the the tagData within the \"this.value\" array collection.\r\n     * since values should be unique, it is suffice to only search by \"value\" property\r\n     * @param {Object} tagData\r\n     */\n    getTagIdx(tagData) {\n      return this.value.findIndex(item => item.__tagId == (tagData || {}).__tagId);\n    },\n    getNodeIndex(node) {\n      var index = 0;\n      if (node) while (node = node.previousElementSibling) index++;\n      return index;\n    },\n    getTagElms() {\n      for (var _len = arguments.length, classess = new Array(_len), _key = 0; _key < _len; _key++) {\n        classess[_key] = arguments[_key];\n      }\n      var classname = '.' + [...this.settings.classNames.tag.split(' '), ...classess].join('.');\n      return [].slice.call(this.DOM.scope.querySelectorAll(classname)); // convert nodeList to Array - https://stackoverflow.com/a/3199627/104380\n    },\n\n    /**\r\n     * gets the last non-readonly, not-in-the-proccess-of-removal tag\r\n     */\n    getLastTag() {\n      var lastTag = this.DOM.scope.querySelectorAll(`${this.settings.classNames.tagSelector}:not(.${this.settings.classNames.tagHide}):not([readonly])`);\n      return lastTag[lastTag.length - 1];\n    },\n    /**\r\n     * Searches if any tag with a certain value already exis\r\n     * @param  {String/Object} value [text value / tag data object]\r\n     * @param  {Boolean} caseSensitive\r\n     * @return {Number}\r\n     */\n    isTagDuplicate(value, caseSensitive, tagId) {\n      var dupsCount = 0,\n        _s = this.settings;\n\n      // duplications are irrelevant for this scenario\n      if (_s.mode == 'select') return false;\n      for (let item of this.value) {\n        let isSameStr = sameStr(this.trim(\"\" + value), item.value, caseSensitive);\n        if (isSameStr && tagId != item.__tagId) dupsCount++;\n      }\n      return dupsCount;\n    },\n    getTagIndexByValue(value) {\n      var indices = [];\n      this.getTagElms().forEach((tagElm, i) => {\n        if (sameStr(this.trim(tagElm.textContent), value, this.settings.dropdown.caseSensitive)) indices.push(i);\n      });\n      return indices;\n    },\n    getTagElmByValue(value) {\n      var tagIdx = this.getTagIndexByValue(value)[0];\n      return this.getTagElms()[tagIdx];\n    },\n    /**\r\n     * Temporarily marks a tag element (by value or Node argument)\r\n     * @param  {Object} tagElm [a specific \"tag\" element to compare to the other tag elements siblings]\r\n     */\n    flashTag(tagElm) {\n      if (tagElm) {\n        tagElm.classList.add(this.settings.classNames.tagFlash);\n        setTimeout(() => {\n          tagElm.classList.remove(this.settings.classNames.tagFlash);\n        }, 100);\n      }\n    },\n    /**\r\n     * checks if text is in the blacklist\r\n     */\n    isTagBlacklisted(v) {\n      v = this.trim(v.toLowerCase());\n      return this.settings.blacklist.filter(x => (\"\" + x).toLowerCase() == v).length;\n    },\n    /**\r\n     * checks if text is in the whitelist\r\n     */\n    isTagWhitelisted(v) {\n      return !!this.getWhitelistItem(v);\n      /*\r\n      return this.settings.whitelist.some(item =>\r\n          typeof v == 'string'\r\n              ? sameStr(this.trim(v), (item.value || item))\r\n              : sameStr(JSON.stringify(item), JSON.stringify(v))\r\n      )\r\n      */\n    },\n\n    /**\r\n     * Returns the first whitelist item matched, by value (if match found)\r\n     * @param {String} value [text to match by]\r\n     */\n    getWhitelistItem(value, prop, whitelist) {\n      var result,\n        prop = prop || 'value',\n        _s = this.settings,\n        whitelist = whitelist || _s.whitelist;\n      whitelist.some(_wi => {\n        var _wiv = typeof _wi == 'string' ? _wi : _wi[prop] || _wi.value,\n          isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim);\n        if (isSameStr) {\n          result = typeof _wi == 'string' ? {\n            value: _wi\n          } : _wi;\n          return true;\n        }\n      });\n\n      // first iterate the whitelist, try find matches by \"value\" and if that fails\n      // and a \"tagTextProp\" is set to be other than \"value\", try that also\n      if (!result && prop == 'value' && _s.tagTextProp != 'value') {\n        // if found, adds the first which matches\n        result = this.getWhitelistItem(value, _s.tagTextProp, whitelist);\n      }\n      return result;\n    },\n    /**\r\n     * validate a tag object BEFORE the actual tag will be created & appeneded\r\n     * @param  {String} s\r\n     * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]\r\n     * @return {Boolean/String}  [\"true\" if validation has passed, String for a fail]\r\n     */\n    validateTag(tagData) {\n      var _s = this.settings,\n        // when validating a tag in edit-mode, need to take \"tagTextProp\" into consideration\n        prop = \"value\" in tagData ? \"value\" : _s.tagTextProp,\n        v = this.trim(tagData[prop] + \"\");\n\n      // check for definitive empty value\n      if (!(tagData[prop] + \"\").trim()) return this.TEXTS.empty;\n\n      // check if pattern should be used and if so, use it to test the value\n      if (_s.pattern && _s.pattern instanceof RegExp && !_s.pattern.test(v)) return this.TEXTS.pattern;\n\n      // check for duplicates\n      if (!_s.duplicates && this.isTagDuplicate(v, _s.dropdown.caseSensitive, tagData.__tagId)) return this.TEXTS.duplicate;\n      if (this.isTagBlacklisted(v) || _s.enforceWhitelist && !this.isTagWhitelisted(v)) return this.TEXTS.notAllowed;\n      if (_s.validate) return _s.validate(tagData);\n      return true;\n    },\n    getInvalidTagAttrs(tagData, validation) {\n      return {\n        \"aria-invalid\": true,\n        \"class\": `${tagData.class || ''} ${this.settings.classNames.tagNotAllowed}`.trim(),\n        \"title\": validation\n      };\n    },\n    hasMaxTags() {\n      return this.value.length >= this.settings.maxTags ? this.TEXTS.exceed : false;\n    },\n    setReadonly(toggle, attrribute) {\n      var _s = this.settings;\n      document.activeElement.blur(); // exit possible edit-mode\n      _s[attrribute || 'readonly'] = toggle;\n      this.DOM.scope[(toggle ? 'set' : 'remove') + 'Attribute'](attrribute || 'readonly', true);\n      this.setContentEditable(!toggle);\n    },\n    setContentEditable(state) {\n      if (!this.settings.userInput) return;\n      this.DOM.input.contentEditable = state;\n      this.DOM.input.tabIndex = !!state ? 0 : -1;\n    },\n    setDisabled(isDisabled) {\n      this.setReadonly(isDisabled, 'disabled');\n    },\n    /**\r\n     * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words\r\n     * so each item should be iterated on and a tag created for.\r\n     * @return {Array} [Array of Objects]\r\n     */\n    normalizeTags(tagsItems) {\n      var _this$settings = this.settings,\n        whitelist = _this$settings.whitelist,\n        delimiters = _this$settings.delimiters,\n        mode = _this$settings.mode,\n        tagTextProp = _this$settings.tagTextProp,\n        whitelistMatches = [],\n        whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false,\n        isArray = Array.isArray(tagsItems),\n        isCollection = isArray && tagsItems[0].value,\n        mapStringToCollection = s => (s + \"\").split(delimiters).filter(n => n).map(v => ({\n          [tagTextProp]: this.trim(v),\n          value: this.trim(v)\n        }));\n      if (typeof tagsItems == 'number') tagsItems = tagsItems.toString();\n\n      // if the argument is a \"simple\" String, ex: \"aaa, bbb, ccc\"\n      if (typeof tagsItems == 'string') {\n        if (!tagsItems.trim()) return [];\n\n        // go over each tag and add it (if there were multiple ones)\n        tagsItems = mapStringToCollection(tagsItems);\n      }\n\n      // if is an Array of Strings, convert to an Array of Objects\n      else if (isArray) {\n        // flatten the 2D array\n        tagsItems = [].concat(...tagsItems.map(item => item.value ? item // mapStringToCollection(item.value).map(newItem => ({...item,...newItem}))\n        : mapStringToCollection(item)));\n      }\n\n      // search if the tag exists in the whitelist as an Object (has props),\n      // to be able to use its properties.\n      // skip matching collections with whitelist items as they are considered \"whole\"\n      if (whitelistWithProps && !isCollection) {\n        tagsItems.forEach(item => {\n          var whitelistMatchesValues = whitelistMatches.map(a => a.value);\n\n          // if suggestions are shown, they are already filtered, so it's easier to use them,\n          // because the whitelist might also include items which have already been added\n          var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], {\n            exact: true\n          });\n          if (!this.settings.duplicates)\n            // also filter out items which have already been matched in previous iterations\n            filteredList = filteredList.filter(filteredItem => !whitelistMatchesValues.includes(filteredItem.value));\n\n          // get the best match out of list of possible matches.\n          // if there was a single item in the filtered list, use that one\n          var matchObj = filteredList.length > 1 ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList) : filteredList[0];\n          if (matchObj && matchObj instanceof Object) {\n            whitelistMatches.push(matchObj); // set the Array (with the found Object) as the new value\n          } else if (mode != 'mix') {\n            if (item.value == undefined) item.value = item[tagTextProp];\n            whitelistMatches.push(item);\n          }\n        });\n        if (whitelistMatches.length) tagsItems = whitelistMatches;\n      }\n      return tagsItems;\n    },\n    /**\r\n     * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags\r\n     * https://stackoverflow.com/a/57598892/104380\r\n     * @param {String} s\r\n     */\n    parseMixTags(s) {\n      var _this$settings2 = this.settings,\n        mixTagsInterpolator = _this$settings2.mixTagsInterpolator,\n        duplicates = _this$settings2.duplicates,\n        transformTag = _this$settings2.transformTag,\n        enforceWhitelist = _this$settings2.enforceWhitelist,\n        maxTags = _this$settings2.maxTags,\n        tagTextProp = _this$settings2.tagTextProp,\n        tagsDataSet = [];\n      s = s.split(mixTagsInterpolator[0]).map((s1, i) => {\n        var s2 = s1.split(mixTagsInterpolator[1]),\n          preInterpolated = s2[0],\n          maxTagsReached = tagsDataSet.length == maxTags,\n          textProp,\n          tagData,\n          tagElm;\n        try {\n          // skip numbers and go straight to the \"catch\" statement\n          if (preInterpolated == +preInterpolated) throw Error;\n          tagData = JSON.parse(preInterpolated);\n        } catch (err) {\n          tagData = this.normalizeTags(preInterpolated)[0] || {\n            value: preInterpolated\n          };\n        }\n        transformTag.call(this, tagData);\n        if (!maxTagsReached && s2.length > 1 && (!enforceWhitelist || this.isTagWhitelisted(tagData.value)) && !(!duplicates && this.isTagDuplicate(tagData.value))) {\n          // in case \"tagTextProp\" setting is set to other than \"value\" and this tag does not have this prop\n          textProp = tagData[tagTextProp] ? tagTextProp : 'value';\n          tagData[textProp] = this.trim(tagData[textProp]);\n          tagElm = this.createTagElem(tagData);\n          tagsDataSet.push(tagData);\n          tagElm.classList.add(this.settings.classNames.tagNoAnimation);\n          s2[0] = tagElm.outerHTML; //+ \"&#8288;\"  // put a zero-space at the end so the caret won't jump back to the start (when the last input's child element is a tag)\n          this.value.push(tagData);\n        } else if (s1) return i ? mixTagsInterpolator[0] + s1 : s1;\n        return s2.join('');\n      }).join('');\n      this.DOM.input.innerHTML = s;\n      this.DOM.input.appendChild(document.createTextNode(''));\n      this.DOM.input.normalize();\n      this.getTagElms().forEach((elm, idx) => getSetTagData(elm, tagsDataSet[idx]));\n      this.update({\n        withoutChangeEvent: true\n      });\n      return s;\n    },\n    /**\r\n     * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)\r\n     * First there *has* to be a \"this.state.tag\" which is a string that was just typed and is staring with a prefix\r\n     */\n    replaceTextWithNode(newWrapperNode, strToReplace) {\n      if (!this.state.tag && !strToReplace) return;\n      strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;\n      var idx,\n        nodeToReplace,\n        selection = this.state.selection || window.getSelection(),\n        nodeAtCaret = selection.anchorNode,\n        firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;\n\n      // STEP 1: ex. replace #ba with the tag \"bart\" where \"|\" is where the caret is:\n      // CURRENT STATE: \"foo #ba #ba| #ba\"\n\n      // split the text node at the index of the caret\n      nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset);\n\n      // node 0: \"foo #ba #ba|\"\n      // node 1: \" #ba\"\n\n      // get index of LAST occurence of \"#ba\"\n      idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace);\n      if (idx == -1) return true;\n      nodeToReplace = nodeAtCaret.splitText(idx);\n\n      // node 0: \"foo #ba \"\n      // node 1: \"#ba\"    <- nodeToReplace\n\n      newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace);\n\n      // must NOT normalize contenteditable or it will cause unwanted issues:\n      // https://monosnap.com/file/ZDVmRvq5upYkidiFedvrwzSswegWk7\n      // nodeAtCaret.parentNode.normalize()\n\n      return true;\n    },\n    /**\r\n     * For selecting a single option (not used for multiple tags, but for \"mode:select\" only)\r\n     * @param {Object} tagElm   Tag DOM node\r\n     * @param {Object} tagData  Tag data\r\n     */\n    selectTag(tagElm, tagData) {\n      var _s = this.settings;\n      if (_s.enforceWhitelist && !this.isTagWhitelisted(tagData.value)) return;\n      this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true);\n\n      // place the caret at the end of the input, only if a dropdown option was selected (and not by manually typing another value and clicking \"TAB\")\n      if (this.state.actions.selectOption) setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input));\n      var lastTagElm = this.getLastTag();\n      if (lastTagElm) this.replaceTag(lastTagElm, tagData);else this.appendTag(tagElm);\n\n      // if( _s.enforceWhitelist )\n      //     this.setContentEditable(false);\n\n      this.value[0] = tagData;\n      this.update();\n      this.trigger('add', {\n        tag: tagElm,\n        data: tagData\n      });\n      return [tagElm];\n    },\n    /**\r\n     * add an empty \"tag\" element in an editable state\r\n     */\n    addEmptyTag(initialData) {\n      var tagData = extend({\n          value: \"\"\n        }, initialData || {}),\n        tagElm = this.createTagElem(tagData);\n      getSetTagData(tagElm, tagData);\n\n      // add the tag to the component's DOM\n      this.appendTag(tagElm);\n      this.editTag(tagElm, {\n        skipValidation: true\n      });\n    },\n    /**\r\n     * add a \"tag\" element to the \"tags\" component\r\n     * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\r\n     * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]\r\n     * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]\r\n     * @return {Array} Array of DOM elements (tags)\r\n     */\n    addTags(tagsItems, clearInput, skipInvalid) {\n      var tagElems = [],\n        _s = this.settings,\n        aggregatedinvalidInput = [],\n        frag = document.createDocumentFragment();\n      skipInvalid = skipInvalid || _s.skipInvalid;\n      if (!tagsItems || tagsItems.length == 0) {\n        return tagElems;\n      }\n\n      // converts Array/String/Object to an Array of Objects\n      tagsItems = this.normalizeTags(tagsItems);\n      switch (_s.mode) {\n        case 'mix':\n          return this.addMixTags(tagsItems);\n        case 'select':\n          {\n            clearInput = false;\n            this.removeAllTags();\n          }\n      }\n      this.DOM.input.removeAttribute('style');\n      tagsItems.forEach(tagData => {\n        var tagElm,\n          tagElmParams = {},\n          originalData = Object.assign({}, tagData, {\n            value: tagData.value + \"\"\n          });\n\n        // shallow-clone tagData so later modifications will not apply to the source\n        tagData = Object.assign({}, originalData);\n        _s.transformTag.call(this, tagData);\n        tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData);\n        if (tagData.__isValid !== true) {\n          if (skipInvalid) return;\n\n          // originalData is kept because it might be that this tag is invalid because it is a duplicate of another,\n          // and if that other tags is edited/deleted, this one should be re-validated and if is no more a duplicate - restored\n          extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {\n            __preInvalidData: originalData\n          });\n          if (tagData.__isValid == this.TEXTS.duplicate)\n            // mark, for a brief moment, the tag (this this one) which THIS CURRENT tag is a duplcate of\n            this.flashTag(this.getTagElmByValue(tagData.value));\n          if (!_s.createInvalidTags) {\n            aggregatedinvalidInput.push(tagData.value);\n            return;\n          }\n        }\n        if ('readonly' in tagData) {\n          if (tagData.readonly) tagElmParams[\"aria-readonly\"] = true;\n          // if \"readonly\" is \"false\", remove it from the tagData so it won't be added as an attribute in the template\n          else delete tagData.readonly;\n        }\n\n        // Create tag HTML element\n        tagElm = this.createTagElem(tagData, tagElmParams);\n        tagElems.push(tagElm);\n\n        // mode-select overrides\n        if (_s.mode == 'select') {\n          return this.selectTag(tagElm, tagData);\n        }\n\n        // add the tag to the component's DOM\n        // this.appendTag(tagElm)\n        frag.appendChild(tagElm);\n        if (tagData.__isValid && tagData.__isValid === true) {\n          // update state\n          this.value.push(tagData);\n          this.trigger('add', {\n            tag: tagElm,\n            index: this.value.length - 1,\n            data: tagData\n          });\n        } else {\n          this.trigger(\"invalid\", {\n            data: tagData,\n            index: this.value.length,\n            tag: tagElm,\n            message: tagData.__isValid\n          });\n          if (!_s.keepInvalidTags)\n            // remove invalid tags (if \"keepInvalidTags\" is set to \"false\")\n            setTimeout(() => this.removeTags(tagElm, true), 1000);\n        }\n        this.dropdown.position(); // reposition the dropdown because the just-added tag might cause a new-line\n      });\n\n      this.appendTag(frag);\n      this.update();\n      if (tagsItems.length && clearInput) {\n        this.input.set.call(this, _s.createInvalidTags ? '' : aggregatedinvalidInput.join(_s._delimiters));\n        this.setRangeAtStartEnd(false, this.DOM.input);\n      }\n      _s.dropdown.enabled && this.dropdown.refilter();\n      return tagElems;\n    },\n    /**\r\n     * Adds a mix-content tag\r\n     * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings\r\n     */\n    addMixTags(tagsData) {\n      tagsData = this.normalizeTags(tagsData);\n      if (tagsData[0].prefix || this.state.tag) {\n        return this.prefixedTextToTag(tagsData[0]);\n      }\n      if (typeof tagsData == 'string') tagsData = [{\n        value: tagsData\n      }];\n      var frag = document.createDocumentFragment();\n      tagsData.forEach(tagData => {\n        var tagElm = this.createTagElem(tagData);\n        frag.appendChild(tagElm);\n        this.insertAfterTag(tagElm);\n      });\n      this.appendMixTags(frag);\n      return frag;\n    },\n    appendMixTags(node) {\n      var selection = !!this.state.selection;\n\n      // if \"selection\" exists, assumes intention of inecting the new tag at the last\n      // saved location of the caret inside \"this.DOM.input\"\n      if (selection) {\n        this.injectAtCaret(node);\n      }\n      // else, create a range and inject the new tag as the last child of \"this.DOM.input\"\n      else {\n        this.DOM.input.focus();\n        selection = this.setStateSelection();\n        selection.range.setStart(this.DOM.input, selection.range.endOffset);\n        selection.range.setEnd(this.DOM.input, selection.range.endOffset);\n        this.DOM.input.appendChild(node);\n        this.updateValueByDOMTags(); // updates internal \"this.value\"\n        this.update(); // updates original input/textarea\n      }\n    },\n\n    /**\r\n     * Adds a tag which was activly typed by the user\r\n     * @param {String/Array} tagItem   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\r\n     */\n    prefixedTextToTag(tagItem) {\n      var _s = this.settings,\n        tagElm,\n        createdFromDelimiters = this.state.tag.delimiters;\n      _s.transformTag.call(this, tagItem);\n      tagItem.prefix = tagItem.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source || _s.pattern)[0];\n\n      // TODO: should check if the tag is valid\n      tagElm = this.createTagElem(tagItem);\n\n      // tries to replace a taged textNode with a tagElm, and if not able,\n      // insert the new tag to the END if \"addTags\" was called from outside\n      if (!this.replaceTextWithNode(tagElm)) {\n        this.DOM.input.appendChild(tagElm);\n      }\n      setTimeout(() => tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300);\n      this.value.push(tagItem);\n      this.update();\n      if (!createdFromDelimiters) {\n        var elm = this.insertAfterTag(tagElm) || tagElm;\n        this.placeCaretAfterNode(elm);\n      }\n      this.state.tag = null;\n      this.trigger('add', extend({}, {\n        tag: tagElm\n      }, {\n        data: tagItem\n      }));\n      return tagElm;\n    },\n    /**\r\n     * appened (validated) tag to the component's DOM scope\r\n     */\n    appendTag(tagElm) {\n      var DOM = this.DOM,\n        insertBeforeNode = DOM.input;\n\n      //if( insertBeforeNode === DOM.input )\n      DOM.scope.insertBefore(tagElm, insertBeforeNode);\n      //else\n      //    DOM.scope.appendChild(tagElm)\n    },\n\n    /**\r\n     * creates a DOM tag element and injects it into the component (this.DOM.scope)\r\n     * @param  {Object}  tagData [text value & properties for the created tag]\r\n     * @param  {Object}  extraData [properties which are for the HTML template only]\r\n     * @return {Object} [DOM element]\r\n     */\n    createTagElem(tagData, extraData) {\n      tagData.__tagId = getUID();\n      var tagElm,\n        templateData = extend({}, tagData, _objectSpread2({\n          value: escapeHTML(tagData.value + \"\")\n        }, extraData));\n\n      // if( this.settings.readonly )\n      //     tagData.readonly = true\n\n      tagElm = this.parseTemplate('tag', [templateData, this]);\n\n      // crucial for proper caret placement when deleting content. if textNodes are allowed as children of a tag element,\n      // a browser bug casues the caret to be misplaced inside the tag element (especcially affects \"readonly\" tags)\n      removeTextChildNodes(tagElm);\n      // while( tagElm.lastChild.nodeType == 3 )\n      //     tagElm.lastChild.parentNode.removeChild(tagElm.lastChild)\n\n      getSetTagData(tagElm, tagData);\n      return tagElm;\n    },\n    /**\r\n     * re-check all invalid tags.\r\n     * called after a tag was edited or removed\r\n     */\n    reCheckInvalidTags() {\n      var _s = this.settings;\n      this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {\n        var tagData = getSetTagData(tagElm),\n          hasMaxTags = this.hasMaxTags(),\n          tagValidation = this.validateTag(tagData),\n          isValid = tagValidation === true && !hasMaxTags;\n        if (_s.mode == 'select') this.toggleScopeValidation(tagValidation);\n\n        // if the tag has become valid\n        if (isValid) {\n          tagData = tagData.__preInvalidData ? tagData.__preInvalidData : {\n            value: tagData.value\n          };\n          return this.replaceTag(tagElm, tagData);\n        }\n\n        // if the tag is still invaild, set its title as such (reson of invalid might have changed)\n        tagElm.title = hasMaxTags || tagValidation;\n      });\n    },\n    /**\r\n     * Removes a tag\r\n     * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]\r\n     * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]\r\n     * @param  {Number}             tranDuration    [Transition duration in MS]\r\n     * TODO: Allow multiple tags to be removed at-once\r\n     */\n    removeTags(tagElms, silent, tranDuration) {\n      var tagsToRemove,\n        _s = this.settings;\n      tagElms = tagElms && tagElms instanceof HTMLElement ? [tagElms] : tagElms instanceof Array ? tagElms : tagElms ? [tagElms] : [this.getLastTag()];\n\n      // normalize tagElms array values:\n      // 1. removing invalid items\n      // 2, if an item is String try to get the matching Tag HTML node\n      // 3. get the tag data\n      // 4. return a collection of Objects\n      tagsToRemove = tagElms.reduce((elms, tagElm) => {\n        if (tagElm && typeof tagElm == 'string') tagElm = this.getTagElmByValue(tagElm);\n        var tagData = getSetTagData(tagElm);\n        if (tagElm && tagData && !tagData.readonly)\n          // make sure it's a tag and not some other node\n          // because the DOM node might be removed by async animation, the state will be updated while\n          // the node might still be in the DOM, so the \"update\" method should know which nodes to ignore\n          elms.push({\n            node: tagElm,\n            idx: this.getTagIdx(tagData),\n            // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)\n            data: getSetTagData(tagElm, {\n              '__removed': true\n            })\n          });\n        return elms;\n      }, []);\n      tranDuration = typeof tranDuration == \"number\" ? tranDuration : this.CSSVars.tagHideTransition;\n      if (_s.mode == 'select') {\n        tranDuration = 0;\n        this.input.set.call(this);\n      }\n\n      // if only a single tag is to be removed.\n      // skip \"select\" mode because invalid tags are actually set to `this.value`\n      if (tagsToRemove.length == 1 && _s.mode != 'select') {\n        if (tagsToRemove[0].node.classList.contains(_s.classNames.tagNotAllowed)) silent = true;\n      }\n      if (!tagsToRemove.length) return;\n      return _s.hooks.beforeRemoveTag(tagsToRemove, {\n        tagify: this\n      }).then(() => {\n        function removeNode(tag) {\n          if (!tag.node.parentNode) return;\n          tag.node.parentNode.removeChild(tag.node);\n          if (!silent) {\n            // this.removeValueById(tagData.__uid)\n            this.trigger('remove', {\n              tag: tag.node,\n              index: tag.idx,\n              data: tag.data\n            });\n            this.dropdown.refilter();\n            this.dropdown.position();\n            this.DOM.input.normalize(); // best-practice when in mix-mode (safe to do always anyways)\n\n            // check if any of the current tags which might have been marked as \"duplicate\" should be un-marked\n            if (_s.keepInvalidTags) this.reCheckInvalidTags();\n\n            // below code is unfinished. it should iterate all currently invalid edited tags, which their edits have not\n            // changed the value yet, and should re-trigger the check, but since nothing has changed, it does not work...\n            // this.getTagElms(_s.classNames.tagEditing).forEach( this.events.callbacks.onEditTagBlur.bind )\n          } else if (_s.keepInvalidTags) this.trigger('remove', {\n            tag: tag.node,\n            index: tag.idx\n          });\n        }\n        function animation(tag) {\n          tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + 'px';\n          document.body.clientTop; // force repaint for the width to take affect before the \"hide\" class below\n          tag.node.classList.add(_s.classNames.tagHide);\n\n          // manual timeout (hack, since transitionend cannot be used because of hover)\n          setTimeout(removeNode.bind(this), tranDuration, tag);\n        }\n        if (tranDuration && tranDuration > 10 && tagsToRemove.length == 1) animation.call(this, tagsToRemove[0]);else tagsToRemove.forEach(removeNode.bind(this));\n\n        // update state regardless of animation\n        if (!silent) {\n          this.removeTagsFromValue(tagsToRemove.map(tag => tag.node));\n          this.update(); // update the original input with the current value\n\n          if (_s.mode == 'select') this.setContentEditable(true);\n        }\n      }).catch(reason => {});\n    },\n    removeTagsFromDOM() {\n      [].slice.call(this.getTagElms()).forEach(elm => elm.parentNode.removeChild(elm));\n    },\n    /**\r\n     * @param {Array/Node} tags to be removed from the this.value array\r\n     */\n    removeTagsFromValue(tags) {\n      tags = Array.isArray(tags) ? tags : [tags];\n      tags.forEach(tag => {\n        var tagData = getSetTagData(tag),\n          tagIdx = this.getTagIdx(tagData);\n\n        //  delete tagData.__removed\n\n        if (tagIdx > -1) this.value.splice(tagIdx, 1);\n      });\n    },\n    removeAllTags(opts) {\n      opts = opts || {};\n      this.value = [];\n      if (this.settings.mode == 'mix') this.DOM.input.innerHTML = '';else this.removeTagsFromDOM();\n      this.dropdown.refilter();\n      this.dropdown.position();\n      if (this.state.dropdown.visible) setTimeout(() => {\n        this.DOM.input.focus();\n      });\n      if (this.settings.mode == 'select') {\n        this.input.set.call(this);\n        this.setContentEditable(true);\n      }\n\n      // technically for now only \"withoutChangeEvent\" exists in the opts.\n      // if more properties will be added later, only pass what's needed to \"update\"\n      this.update(opts);\n    },\n    postUpdate() {\n      var _s = this.settings,\n        classNames = _s.classNames,\n        hasValue = _s.mode == 'mix' ? _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;\n      this.toggleClass(classNames.hasMaxTags, this.value.length >= _s.maxTags);\n      this.toggleClass(classNames.hasNoTags, !this.value.length);\n      this.toggleClass(classNames.empty, !hasValue);\n\n      // specifically the \"select mode\" might have the \"invalid\" classname set when the field is changed, so it must be toggled on add/remove/edit\n      if (_s.mode == 'select') {\n        this.toggleScopeValidation(this.value?.[0]?.__isValid);\n      }\n    },\n    setOriginalInputValue(v) {\n      var inputElm = this.DOM.originalInput;\n      if (!this.settings.mixMode.integrated) {\n        inputElm.value = v;\n        inputElm.tagifyValue = inputElm.value; // must set to \"inputElm.value\" and not again to \"inputValue\" because for some reason the browser changes the string afterwards a bit.\n        this.setPersistedData(v, 'value');\n      }\n    },\n    /**\r\n     * update the origianl (hidden) input field's value\r\n     * see - https://stackoverflow.com/q/50957841/104380\r\n     */\n    update(args) {\n      const UPDATE_DELAY = 100;\n      clearTimeout(this.debouncedUpdateTimeout);\n      this.debouncedUpdateTimeout = setTimeout(reallyUpdate.bind(this), UPDATE_DELAY);\n      function reallyUpdate() {\n        var inputValue = this.getInputValue();\n        this.setOriginalInputValue(inputValue);\n        this.postUpdate();\n        if ((!this.settings.onChangeAfterBlur || !(args || {}).withoutChangeEvent) && !this.state.blockChangeEvent) this.triggerChangeEvent();\n      }\n    },\n    getInputValue() {\n      var value = this.getCleanValue();\n      return this.settings.mode == 'mix' ? this.getMixedTagsAsString(value) : value.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(value) : JSON.stringify(value) : \"\";\n    },\n    /**\r\n     * removes properties from `this.value` which are only used internally\r\n     */\n    getCleanValue(v) {\n      return removeCollectionProp(v || this.value, this.dataProps);\n    },\n    getMixedTagsAsString() {\n      var result = \"\",\n        that = this,\n        _s = this.settings,\n        originalInputValueFormat = _s.originalInputValueFormat || JSON.stringify,\n        _interpolator = _s.mixTagsInterpolator;\n      function iterateChildren(rootNode) {\n        rootNode.childNodes.forEach(node => {\n          if (node.nodeType == 1) {\n            const tagData = getSetTagData(node);\n            if (node.tagName == 'BR') {\n              result += \"\\r\\n\";\n            }\n            if (tagData && isNodeTag.call(that, node)) {\n              if (tagData.__removed) return;else result += _interpolator[0] + originalInputValueFormat(omit(tagData, that.dataProps)) + _interpolator[1];\n            } else if (node.getAttribute('style') || ['B', 'I', 'U'].includes(node.tagName)) result += node.textContent;else if (node.tagName == 'DIV' || node.tagName == 'P') {\n              result += \"\\r\\n\";\n              //  if( !node.children.length && node.textContent )\n              //  result += node.textContent;\n              iterateChildren(node);\n            }\n          } else result += node.textContent;\n        });\n      }\n      iterateChildren(this.DOM.input);\n      return result;\n    }\n  };\n\n  // legacy support for changed methods names\n  Tagify.prototype.removeTag = Tagify.prototype.removeTags;\n\n  return Tagify;\n\n}));\n"]},"metadata":{},"sourceType":"script"}